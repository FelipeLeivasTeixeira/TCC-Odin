
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tb_usuarios
 * 
 */
export type Tb_usuarios = $Result.DefaultSelection<Prisma.$Tb_usuariosPayload>
/**
 * Model Tb_categoria
 * 
 */
export type Tb_categoria = $Result.DefaultSelection<Prisma.$Tb_categoriaPayload>
/**
 * Model Tb_perguntas
 * 
 */
export type Tb_perguntas = $Result.DefaultSelection<Prisma.$Tb_perguntasPayload>
/**
 * Model Tb_respostas
 * 
 */
export type Tb_respostas = $Result.DefaultSelection<Prisma.$Tb_respostasPayload>
/**
 * Model Tb_avaliacoes
 * 
 */
export type Tb_avaliacoes = $Result.DefaultSelection<Prisma.$Tb_avaliacoesPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tb_usuarios
 * const tb_usuarios = await prisma.tb_usuarios.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tb_usuarios
   * const tb_usuarios = await prisma.tb_usuarios.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tb_usuarios`: Exposes CRUD operations for the **Tb_usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_usuarios
    * const tb_usuarios = await prisma.tb_usuarios.findMany()
    * ```
    */
  get tb_usuarios(): Prisma.Tb_usuariosDelegate<ExtArgs>;

  /**
   * `prisma.tb_categoria`: Exposes CRUD operations for the **Tb_categoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_categorias
    * const tb_categorias = await prisma.tb_categoria.findMany()
    * ```
    */
  get tb_categoria(): Prisma.Tb_categoriaDelegate<ExtArgs>;

  /**
   * `prisma.tb_perguntas`: Exposes CRUD operations for the **Tb_perguntas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_perguntas
    * const tb_perguntas = await prisma.tb_perguntas.findMany()
    * ```
    */
  get tb_perguntas(): Prisma.Tb_perguntasDelegate<ExtArgs>;

  /**
   * `prisma.tb_respostas`: Exposes CRUD operations for the **Tb_respostas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_respostas
    * const tb_respostas = await prisma.tb_respostas.findMany()
    * ```
    */
  get tb_respostas(): Prisma.Tb_respostasDelegate<ExtArgs>;

  /**
   * `prisma.tb_avaliacoes`: Exposes CRUD operations for the **Tb_avaliacoes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tb_avaliacoes
    * const tb_avaliacoes = await prisma.tb_avaliacoes.findMany()
    * ```
    */
  get tb_avaliacoes(): Prisma.Tb_avaliacoesDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.12.1
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tb_usuarios: 'Tb_usuarios',
    Tb_categoria: 'Tb_categoria',
    Tb_perguntas: 'Tb_perguntas',
    Tb_respostas: 'Tb_respostas',
    Tb_avaliacoes: 'Tb_avaliacoes'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'tb_usuarios' | 'tb_categoria' | 'tb_perguntas' | 'tb_respostas' | 'tb_avaliacoes'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Tb_usuarios: {
        payload: Prisma.$Tb_usuariosPayload<ExtArgs>
        fields: Prisma.Tb_usuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tb_usuariosFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tb_usuariosFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>
          }
          findFirst: {
            args: Prisma.Tb_usuariosFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tb_usuariosFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>
          }
          findMany: {
            args: Prisma.Tb_usuariosFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>[]
          }
          create: {
            args: Prisma.Tb_usuariosCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>
          }
          createMany: {
            args: Prisma.Tb_usuariosCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Tb_usuariosDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>
          }
          update: {
            args: Prisma.Tb_usuariosUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>
          }
          deleteMany: {
            args: Prisma.Tb_usuariosDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Tb_usuariosUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Tb_usuariosUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_usuariosPayload>
          }
          aggregate: {
            args: Prisma.Tb_usuariosAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_usuarios>
          }
          groupBy: {
            args: Prisma.Tb_usuariosGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_usuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tb_usuariosCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_usuariosCountAggregateOutputType> | number
          }
        }
      }
      Tb_categoria: {
        payload: Prisma.$Tb_categoriaPayload<ExtArgs>
        fields: Prisma.Tb_categoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tb_categoriaFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tb_categoriaFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>
          }
          findFirst: {
            args: Prisma.Tb_categoriaFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tb_categoriaFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>
          }
          findMany: {
            args: Prisma.Tb_categoriaFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>[]
          }
          create: {
            args: Prisma.Tb_categoriaCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>
          }
          createMany: {
            args: Prisma.Tb_categoriaCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Tb_categoriaDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>
          }
          update: {
            args: Prisma.Tb_categoriaUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>
          }
          deleteMany: {
            args: Prisma.Tb_categoriaDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Tb_categoriaUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Tb_categoriaUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_categoriaPayload>
          }
          aggregate: {
            args: Prisma.Tb_categoriaAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_categoria>
          }
          groupBy: {
            args: Prisma.Tb_categoriaGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_categoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tb_categoriaCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_categoriaCountAggregateOutputType> | number
          }
        }
      }
      Tb_perguntas: {
        payload: Prisma.$Tb_perguntasPayload<ExtArgs>
        fields: Prisma.Tb_perguntasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tb_perguntasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tb_perguntasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>
          }
          findFirst: {
            args: Prisma.Tb_perguntasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tb_perguntasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>
          }
          findMany: {
            args: Prisma.Tb_perguntasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>[]
          }
          create: {
            args: Prisma.Tb_perguntasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>
          }
          createMany: {
            args: Prisma.Tb_perguntasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Tb_perguntasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>
          }
          update: {
            args: Prisma.Tb_perguntasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>
          }
          deleteMany: {
            args: Prisma.Tb_perguntasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Tb_perguntasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Tb_perguntasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_perguntasPayload>
          }
          aggregate: {
            args: Prisma.Tb_perguntasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_perguntas>
          }
          groupBy: {
            args: Prisma.Tb_perguntasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_perguntasGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tb_perguntasCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_perguntasCountAggregateOutputType> | number
          }
        }
      }
      Tb_respostas: {
        payload: Prisma.$Tb_respostasPayload<ExtArgs>
        fields: Prisma.Tb_respostasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tb_respostasFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tb_respostasFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>
          }
          findFirst: {
            args: Prisma.Tb_respostasFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tb_respostasFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>
          }
          findMany: {
            args: Prisma.Tb_respostasFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>[]
          }
          create: {
            args: Prisma.Tb_respostasCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>
          }
          createMany: {
            args: Prisma.Tb_respostasCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Tb_respostasDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>
          }
          update: {
            args: Prisma.Tb_respostasUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>
          }
          deleteMany: {
            args: Prisma.Tb_respostasDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Tb_respostasUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Tb_respostasUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_respostasPayload>
          }
          aggregate: {
            args: Prisma.Tb_respostasAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_respostas>
          }
          groupBy: {
            args: Prisma.Tb_respostasGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_respostasGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tb_respostasCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_respostasCountAggregateOutputType> | number
          }
        }
      }
      Tb_avaliacoes: {
        payload: Prisma.$Tb_avaliacoesPayload<ExtArgs>
        fields: Prisma.Tb_avaliacoesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Tb_avaliacoesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Tb_avaliacoesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>
          }
          findFirst: {
            args: Prisma.Tb_avaliacoesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Tb_avaliacoesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>
          }
          findMany: {
            args: Prisma.Tb_avaliacoesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>[]
          }
          create: {
            args: Prisma.Tb_avaliacoesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>
          }
          createMany: {
            args: Prisma.Tb_avaliacoesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Tb_avaliacoesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>
          }
          update: {
            args: Prisma.Tb_avaliacoesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>
          }
          deleteMany: {
            args: Prisma.Tb_avaliacoesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Tb_avaliacoesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Tb_avaliacoesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Tb_avaliacoesPayload>
          }
          aggregate: {
            args: Prisma.Tb_avaliacoesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTb_avaliacoes>
          }
          groupBy: {
            args: Prisma.Tb_avaliacoesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Tb_avaliacoesGroupByOutputType>[]
          }
          count: {
            args: Prisma.Tb_avaliacoesCountArgs<ExtArgs>,
            result: $Utils.Optional<Tb_avaliacoesCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Tb_usuariosCountOutputType
   */

  export type Tb_usuariosCountOutputType = {
    perguntas: number
    respostas: number
    avaliacoes: number
  }

  export type Tb_usuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perguntas?: boolean | Tb_usuariosCountOutputTypeCountPerguntasArgs
    respostas?: boolean | Tb_usuariosCountOutputTypeCountRespostasArgs
    avaliacoes?: boolean | Tb_usuariosCountOutputTypeCountAvaliacoesArgs
  }

  // Custom InputTypes

  /**
   * Tb_usuariosCountOutputType without action
   */
  export type Tb_usuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuariosCountOutputType
     */
    select?: Tb_usuariosCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_usuariosCountOutputType without action
   */
  export type Tb_usuariosCountOutputTypeCountPerguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_perguntasWhereInput
  }


  /**
   * Tb_usuariosCountOutputType without action
   */
  export type Tb_usuariosCountOutputTypeCountRespostasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_respostasWhereInput
  }


  /**
   * Tb_usuariosCountOutputType without action
   */
  export type Tb_usuariosCountOutputTypeCountAvaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_avaliacoesWhereInput
  }



  /**
   * Count Type Tb_categoriaCountOutputType
   */

  export type Tb_categoriaCountOutputType = {
    pergunta: number
  }

  export type Tb_categoriaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pergunta?: boolean | Tb_categoriaCountOutputTypeCountPerguntaArgs
  }

  // Custom InputTypes

  /**
   * Tb_categoriaCountOutputType without action
   */
  export type Tb_categoriaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoriaCountOutputType
     */
    select?: Tb_categoriaCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_categoriaCountOutputType without action
   */
  export type Tb_categoriaCountOutputTypeCountPerguntaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_perguntasWhereInput
  }



  /**
   * Count Type Tb_perguntasCountOutputType
   */

  export type Tb_perguntasCountOutputType = {
    respostas: number
  }

  export type Tb_perguntasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    respostas?: boolean | Tb_perguntasCountOutputTypeCountRespostasArgs
  }

  // Custom InputTypes

  /**
   * Tb_perguntasCountOutputType without action
   */
  export type Tb_perguntasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntasCountOutputType
     */
    select?: Tb_perguntasCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Tb_perguntasCountOutputType without action
   */
  export type Tb_perguntasCountOutputTypeCountRespostasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_respostasWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Tb_usuarios
   */

  export type AggregateTb_usuarios = {
    _count: Tb_usuariosCountAggregateOutputType | null
    _avg: Tb_usuariosAvgAggregateOutputType | null
    _sum: Tb_usuariosSumAggregateOutputType | null
    _min: Tb_usuariosMinAggregateOutputType | null
    _max: Tb_usuariosMaxAggregateOutputType | null
  }

  export type Tb_usuariosAvgAggregateOutputType = {
    id: number | null
  }

  export type Tb_usuariosSumAggregateOutputType = {
    id: number | null
  }

  export type Tb_usuariosMinAggregateOutputType = {
    id: number | null
    email: string | null
    nome: string | null
    senha: string | null
    arquivo: string | null
  }

  export type Tb_usuariosMaxAggregateOutputType = {
    id: number | null
    email: string | null
    nome: string | null
    senha: string | null
    arquivo: string | null
  }

  export type Tb_usuariosCountAggregateOutputType = {
    id: number
    email: number
    nome: number
    senha: number
    arquivo: number
    _all: number
  }


  export type Tb_usuariosAvgAggregateInputType = {
    id?: true
  }

  export type Tb_usuariosSumAggregateInputType = {
    id?: true
  }

  export type Tb_usuariosMinAggregateInputType = {
    id?: true
    email?: true
    nome?: true
    senha?: true
    arquivo?: true
  }

  export type Tb_usuariosMaxAggregateInputType = {
    id?: true
    email?: true
    nome?: true
    senha?: true
    arquivo?: true
  }

  export type Tb_usuariosCountAggregateInputType = {
    id?: true
    email?: true
    nome?: true
    senha?: true
    arquivo?: true
    _all?: true
  }

  export type Tb_usuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_usuarios to aggregate.
     */
    where?: Tb_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_usuarios to fetch.
     */
    orderBy?: Tb_usuariosOrderByWithRelationInput | Tb_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tb_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tb_usuarios
    **/
    _count?: true | Tb_usuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_usuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_usuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_usuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_usuariosMaxAggregateInputType
  }

  export type GetTb_usuariosAggregateType<T extends Tb_usuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_usuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_usuarios[P]>
      : GetScalarType<T[P], AggregateTb_usuarios[P]>
  }




  export type Tb_usuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_usuariosWhereInput
    orderBy?: Tb_usuariosOrderByWithAggregationInput | Tb_usuariosOrderByWithAggregationInput[]
    by: Tb_usuariosScalarFieldEnum[] | Tb_usuariosScalarFieldEnum
    having?: Tb_usuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_usuariosCountAggregateInputType | true
    _avg?: Tb_usuariosAvgAggregateInputType
    _sum?: Tb_usuariosSumAggregateInputType
    _min?: Tb_usuariosMinAggregateInputType
    _max?: Tb_usuariosMaxAggregateInputType
  }

  export type Tb_usuariosGroupByOutputType = {
    id: number
    email: string
    nome: string
    senha: string
    arquivo: string
    _count: Tb_usuariosCountAggregateOutputType | null
    _avg: Tb_usuariosAvgAggregateOutputType | null
    _sum: Tb_usuariosSumAggregateOutputType | null
    _min: Tb_usuariosMinAggregateOutputType | null
    _max: Tb_usuariosMaxAggregateOutputType | null
  }

  type GetTb_usuariosGroupByPayload<T extends Tb_usuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_usuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_usuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_usuariosGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_usuariosGroupByOutputType[P]>
        }
      >
    >


  export type Tb_usuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    nome?: boolean
    senha?: boolean
    arquivo?: boolean
    perguntas?: boolean | Tb_usuarios$perguntasArgs<ExtArgs>
    respostas?: boolean | Tb_usuarios$respostasArgs<ExtArgs>
    avaliacoes?: boolean | Tb_usuarios$avaliacoesArgs<ExtArgs>
    _count?: boolean | Tb_usuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_usuarios"]>

  export type Tb_usuariosSelectScalar = {
    id?: boolean
    email?: boolean
    nome?: boolean
    senha?: boolean
    arquivo?: boolean
  }

  export type Tb_usuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perguntas?: boolean | Tb_usuarios$perguntasArgs<ExtArgs>
    respostas?: boolean | Tb_usuarios$respostasArgs<ExtArgs>
    avaliacoes?: boolean | Tb_usuarios$avaliacoesArgs<ExtArgs>
    _count?: boolean | Tb_usuariosCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $Tb_usuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tb_usuarios"
    objects: {
      perguntas: Prisma.$Tb_perguntasPayload<ExtArgs>[]
      respostas: Prisma.$Tb_respostasPayload<ExtArgs>[]
      avaliacoes: Prisma.$Tb_avaliacoesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      nome: string
      senha: string
      arquivo: string
    }, ExtArgs["result"]["tb_usuarios"]>
    composites: {}
  }


  type Tb_usuariosGetPayload<S extends boolean | null | undefined | Tb_usuariosDefaultArgs> = $Result.GetResult<Prisma.$Tb_usuariosPayload, S>

  type Tb_usuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tb_usuariosFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tb_usuariosCountAggregateInputType | true
    }

  export interface Tb_usuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tb_usuarios'], meta: { name: 'Tb_usuarios' } }
    /**
     * Find zero or one Tb_usuarios that matches the filter.
     * @param {Tb_usuariosFindUniqueArgs} args - Arguments to find a Tb_usuarios
     * @example
     * // Get one Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Tb_usuariosFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_usuariosFindUniqueArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_usuarios that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Tb_usuariosFindUniqueOrThrowArgs} args - Arguments to find a Tb_usuarios
     * @example
     * // Get one Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Tb_usuariosFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_usuariosFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosFindFirstArgs} args - Arguments to find a Tb_usuarios
     * @example
     * // Get one Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Tb_usuariosFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_usuariosFindFirstArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosFindFirstOrThrowArgs} args - Arguments to find a Tb_usuarios
     * @example
     * // Get one Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Tb_usuariosFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_usuariosFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.findMany()
     * 
     * // Get first 10 Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tb_usuariosWithIdOnly = await prisma.tb_usuarios.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Tb_usuariosFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_usuariosFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_usuarios.
     * @param {Tb_usuariosCreateArgs} args - Arguments to create a Tb_usuarios.
     * @example
     * // Create one Tb_usuarios
     * const Tb_usuarios = await prisma.tb_usuarios.create({
     *   data: {
     *     // ... data to create a Tb_usuarios
     *   }
     * })
     * 
    **/
    create<T extends Tb_usuariosCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_usuariosCreateArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_usuarios.
     *     @param {Tb_usuariosCreateManyArgs} args - Arguments to create many Tb_usuarios.
     *     @example
     *     // Create many Tb_usuarios
     *     const tb_usuarios = await prisma.tb_usuarios.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Tb_usuariosCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_usuariosCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_usuarios.
     * @param {Tb_usuariosDeleteArgs} args - Arguments to delete one Tb_usuarios.
     * @example
     * // Delete one Tb_usuarios
     * const Tb_usuarios = await prisma.tb_usuarios.delete({
     *   where: {
     *     // ... filter to delete one Tb_usuarios
     *   }
     * })
     * 
    **/
    delete<T extends Tb_usuariosDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_usuariosDeleteArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_usuarios.
     * @param {Tb_usuariosUpdateArgs} args - Arguments to update one Tb_usuarios.
     * @example
     * // Update one Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Tb_usuariosUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_usuariosUpdateArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_usuarios.
     * @param {Tb_usuariosDeleteManyArgs} args - Arguments to filter Tb_usuarios to delete.
     * @example
     * // Delete a few Tb_usuarios
     * const { count } = await prisma.tb_usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Tb_usuariosDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_usuariosDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Tb_usuariosUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_usuariosUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_usuarios.
     * @param {Tb_usuariosUpsertArgs} args - Arguments to update or create a Tb_usuarios.
     * @example
     * // Update or create a Tb_usuarios
     * const tb_usuarios = await prisma.tb_usuarios.upsert({
     *   create: {
     *     // ... data to create a Tb_usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_usuarios we want to update
     *   }
     * })
    **/
    upsert<T extends Tb_usuariosUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_usuariosUpsertArgs<ExtArgs>>
    ): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosCountArgs} args - Arguments to filter Tb_usuarios to count.
     * @example
     * // Count the number of Tb_usuarios
     * const count = await prisma.tb_usuarios.count({
     *   where: {
     *     // ... the filter for the Tb_usuarios we want to count
     *   }
     * })
    **/
    count<T extends Tb_usuariosCountArgs>(
      args?: Subset<T, Tb_usuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_usuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_usuariosAggregateArgs>(args: Subset<T, Tb_usuariosAggregateArgs>): Prisma.PrismaPromise<GetTb_usuariosAggregateType<T>>

    /**
     * Group by Tb_usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_usuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tb_usuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tb_usuariosGroupByArgs['orderBy'] }
        : { orderBy?: Tb_usuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tb_usuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_usuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tb_usuarios model
   */
  readonly fields: Tb_usuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tb_usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tb_usuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    perguntas<T extends Tb_usuarios$perguntasArgs<ExtArgs> = {}>(args?: Subset<T, Tb_usuarios$perguntasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findMany'> | Null>;

    respostas<T extends Tb_usuarios$respostasArgs<ExtArgs> = {}>(args?: Subset<T, Tb_usuarios$respostasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findMany'> | Null>;

    avaliacoes<T extends Tb_usuarios$avaliacoesArgs<ExtArgs> = {}>(args?: Subset<T, Tb_usuarios$avaliacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tb_usuarios model
   */ 
  interface Tb_usuariosFieldRefs {
    readonly id: FieldRef<"Tb_usuarios", 'Int'>
    readonly email: FieldRef<"Tb_usuarios", 'String'>
    readonly nome: FieldRef<"Tb_usuarios", 'String'>
    readonly senha: FieldRef<"Tb_usuarios", 'String'>
    readonly arquivo: FieldRef<"Tb_usuarios", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tb_usuarios findUnique
   */
  export type Tb_usuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which Tb_usuarios to fetch.
     */
    where: Tb_usuariosWhereUniqueInput
  }


  /**
   * Tb_usuarios findUniqueOrThrow
   */
  export type Tb_usuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which Tb_usuarios to fetch.
     */
    where: Tb_usuariosWhereUniqueInput
  }


  /**
   * Tb_usuarios findFirst
   */
  export type Tb_usuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which Tb_usuarios to fetch.
     */
    where?: Tb_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_usuarios to fetch.
     */
    orderBy?: Tb_usuariosOrderByWithRelationInput | Tb_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_usuarios.
     */
    cursor?: Tb_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_usuarios.
     */
    distinct?: Tb_usuariosScalarFieldEnum | Tb_usuariosScalarFieldEnum[]
  }


  /**
   * Tb_usuarios findFirstOrThrow
   */
  export type Tb_usuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which Tb_usuarios to fetch.
     */
    where?: Tb_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_usuarios to fetch.
     */
    orderBy?: Tb_usuariosOrderByWithRelationInput | Tb_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_usuarios.
     */
    cursor?: Tb_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_usuarios.
     */
    distinct?: Tb_usuariosScalarFieldEnum | Tb_usuariosScalarFieldEnum[]
  }


  /**
   * Tb_usuarios findMany
   */
  export type Tb_usuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * Filter, which Tb_usuarios to fetch.
     */
    where?: Tb_usuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_usuarios to fetch.
     */
    orderBy?: Tb_usuariosOrderByWithRelationInput | Tb_usuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tb_usuarios.
     */
    cursor?: Tb_usuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_usuarios.
     */
    skip?: number
    distinct?: Tb_usuariosScalarFieldEnum | Tb_usuariosScalarFieldEnum[]
  }


  /**
   * Tb_usuarios create
   */
  export type Tb_usuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Tb_usuarios.
     */
    data: XOR<Tb_usuariosCreateInput, Tb_usuariosUncheckedCreateInput>
  }


  /**
   * Tb_usuarios createMany
   */
  export type Tb_usuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tb_usuarios.
     */
    data: Tb_usuariosCreateManyInput | Tb_usuariosCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tb_usuarios update
   */
  export type Tb_usuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Tb_usuarios.
     */
    data: XOR<Tb_usuariosUpdateInput, Tb_usuariosUncheckedUpdateInput>
    /**
     * Choose, which Tb_usuarios to update.
     */
    where: Tb_usuariosWhereUniqueInput
  }


  /**
   * Tb_usuarios updateMany
   */
  export type Tb_usuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tb_usuarios.
     */
    data: XOR<Tb_usuariosUpdateManyMutationInput, Tb_usuariosUncheckedUpdateManyInput>
    /**
     * Filter which Tb_usuarios to update
     */
    where?: Tb_usuariosWhereInput
  }


  /**
   * Tb_usuarios upsert
   */
  export type Tb_usuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Tb_usuarios to update in case it exists.
     */
    where: Tb_usuariosWhereUniqueInput
    /**
     * In case the Tb_usuarios found by the `where` argument doesn't exist, create a new Tb_usuarios with this data.
     */
    create: XOR<Tb_usuariosCreateInput, Tb_usuariosUncheckedCreateInput>
    /**
     * In case the Tb_usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tb_usuariosUpdateInput, Tb_usuariosUncheckedUpdateInput>
  }


  /**
   * Tb_usuarios delete
   */
  export type Tb_usuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
    /**
     * Filter which Tb_usuarios to delete.
     */
    where: Tb_usuariosWhereUniqueInput
  }


  /**
   * Tb_usuarios deleteMany
   */
  export type Tb_usuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_usuarios to delete
     */
    where?: Tb_usuariosWhereInput
  }


  /**
   * Tb_usuarios.perguntas
   */
  export type Tb_usuarios$perguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    where?: Tb_perguntasWhereInput
    orderBy?: Tb_perguntasOrderByWithRelationInput | Tb_perguntasOrderByWithRelationInput[]
    cursor?: Tb_perguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_perguntasScalarFieldEnum | Tb_perguntasScalarFieldEnum[]
  }


  /**
   * Tb_usuarios.respostas
   */
  export type Tb_usuarios$respostasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    where?: Tb_respostasWhereInput
    orderBy?: Tb_respostasOrderByWithRelationInput | Tb_respostasOrderByWithRelationInput[]
    cursor?: Tb_respostasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_respostasScalarFieldEnum | Tb_respostasScalarFieldEnum[]
  }


  /**
   * Tb_usuarios.avaliacoes
   */
  export type Tb_usuarios$avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    where?: Tb_avaliacoesWhereInput
    orderBy?: Tb_avaliacoesOrderByWithRelationInput | Tb_avaliacoesOrderByWithRelationInput[]
    cursor?: Tb_avaliacoesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_avaliacoesScalarFieldEnum | Tb_avaliacoesScalarFieldEnum[]
  }


  /**
   * Tb_usuarios without action
   */
  export type Tb_usuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_usuarios
     */
    select?: Tb_usuariosSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_usuariosInclude<ExtArgs> | null
  }



  /**
   * Model Tb_categoria
   */

  export type AggregateTb_categoria = {
    _count: Tb_categoriaCountAggregateOutputType | null
    _avg: Tb_categoriaAvgAggregateOutputType | null
    _sum: Tb_categoriaSumAggregateOutputType | null
    _min: Tb_categoriaMinAggregateOutputType | null
    _max: Tb_categoriaMaxAggregateOutputType | null
  }

  export type Tb_categoriaAvgAggregateOutputType = {
    idCat: number | null
  }

  export type Tb_categoriaSumAggregateOutputType = {
    idCat: number | null
  }

  export type Tb_categoriaMinAggregateOutputType = {
    idCat: number | null
    nomeCat: string | null
  }

  export type Tb_categoriaMaxAggregateOutputType = {
    idCat: number | null
    nomeCat: string | null
  }

  export type Tb_categoriaCountAggregateOutputType = {
    idCat: number
    nomeCat: number
    _all: number
  }


  export type Tb_categoriaAvgAggregateInputType = {
    idCat?: true
  }

  export type Tb_categoriaSumAggregateInputType = {
    idCat?: true
  }

  export type Tb_categoriaMinAggregateInputType = {
    idCat?: true
    nomeCat?: true
  }

  export type Tb_categoriaMaxAggregateInputType = {
    idCat?: true
    nomeCat?: true
  }

  export type Tb_categoriaCountAggregateInputType = {
    idCat?: true
    nomeCat?: true
    _all?: true
  }

  export type Tb_categoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_categoria to aggregate.
     */
    where?: Tb_categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_categorias to fetch.
     */
    orderBy?: Tb_categoriaOrderByWithRelationInput | Tb_categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tb_categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tb_categorias
    **/
    _count?: true | Tb_categoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_categoriaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_categoriaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_categoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_categoriaMaxAggregateInputType
  }

  export type GetTb_categoriaAggregateType<T extends Tb_categoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_categoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_categoria[P]>
      : GetScalarType<T[P], AggregateTb_categoria[P]>
  }




  export type Tb_categoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_categoriaWhereInput
    orderBy?: Tb_categoriaOrderByWithAggregationInput | Tb_categoriaOrderByWithAggregationInput[]
    by: Tb_categoriaScalarFieldEnum[] | Tb_categoriaScalarFieldEnum
    having?: Tb_categoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_categoriaCountAggregateInputType | true
    _avg?: Tb_categoriaAvgAggregateInputType
    _sum?: Tb_categoriaSumAggregateInputType
    _min?: Tb_categoriaMinAggregateInputType
    _max?: Tb_categoriaMaxAggregateInputType
  }

  export type Tb_categoriaGroupByOutputType = {
    idCat: number
    nomeCat: string
    _count: Tb_categoriaCountAggregateOutputType | null
    _avg: Tb_categoriaAvgAggregateOutputType | null
    _sum: Tb_categoriaSumAggregateOutputType | null
    _min: Tb_categoriaMinAggregateOutputType | null
    _max: Tb_categoriaMaxAggregateOutputType | null
  }

  type GetTb_categoriaGroupByPayload<T extends Tb_categoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_categoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_categoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_categoriaGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_categoriaGroupByOutputType[P]>
        }
      >
    >


  export type Tb_categoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCat?: boolean
    nomeCat?: boolean
    pergunta?: boolean | Tb_categoria$perguntaArgs<ExtArgs>
    _count?: boolean | Tb_categoriaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_categoria"]>

  export type Tb_categoriaSelectScalar = {
    idCat?: boolean
    nomeCat?: boolean
  }

  export type Tb_categoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pergunta?: boolean | Tb_categoria$perguntaArgs<ExtArgs>
    _count?: boolean | Tb_categoriaCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $Tb_categoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tb_categoria"
    objects: {
      pergunta: Prisma.$Tb_perguntasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idCat: number
      nomeCat: string
    }, ExtArgs["result"]["tb_categoria"]>
    composites: {}
  }


  type Tb_categoriaGetPayload<S extends boolean | null | undefined | Tb_categoriaDefaultArgs> = $Result.GetResult<Prisma.$Tb_categoriaPayload, S>

  type Tb_categoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tb_categoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tb_categoriaCountAggregateInputType | true
    }

  export interface Tb_categoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tb_categoria'], meta: { name: 'Tb_categoria' } }
    /**
     * Find zero or one Tb_categoria that matches the filter.
     * @param {Tb_categoriaFindUniqueArgs} args - Arguments to find a Tb_categoria
     * @example
     * // Get one Tb_categoria
     * const tb_categoria = await prisma.tb_categoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Tb_categoriaFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_categoriaFindUniqueArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_categoria that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Tb_categoriaFindUniqueOrThrowArgs} args - Arguments to find a Tb_categoria
     * @example
     * // Get one Tb_categoria
     * const tb_categoria = await prisma.tb_categoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Tb_categoriaFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_categoriaFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_categoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaFindFirstArgs} args - Arguments to find a Tb_categoria
     * @example
     * // Get one Tb_categoria
     * const tb_categoria = await prisma.tb_categoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Tb_categoriaFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_categoriaFindFirstArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_categoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaFindFirstOrThrowArgs} args - Arguments to find a Tb_categoria
     * @example
     * // Get one Tb_categoria
     * const tb_categoria = await prisma.tb_categoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Tb_categoriaFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_categoriaFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_categorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_categorias
     * const tb_categorias = await prisma.tb_categoria.findMany()
     * 
     * // Get first 10 Tb_categorias
     * const tb_categorias = await prisma.tb_categoria.findMany({ take: 10 })
     * 
     * // Only select the `idCat`
     * const tb_categoriaWithIdCatOnly = await prisma.tb_categoria.findMany({ select: { idCat: true } })
     * 
    **/
    findMany<T extends Tb_categoriaFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_categoriaFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_categoria.
     * @param {Tb_categoriaCreateArgs} args - Arguments to create a Tb_categoria.
     * @example
     * // Create one Tb_categoria
     * const Tb_categoria = await prisma.tb_categoria.create({
     *   data: {
     *     // ... data to create a Tb_categoria
     *   }
     * })
     * 
    **/
    create<T extends Tb_categoriaCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_categoriaCreateArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_categorias.
     *     @param {Tb_categoriaCreateManyArgs} args - Arguments to create many Tb_categorias.
     *     @example
     *     // Create many Tb_categorias
     *     const tb_categoria = await prisma.tb_categoria.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Tb_categoriaCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_categoriaCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_categoria.
     * @param {Tb_categoriaDeleteArgs} args - Arguments to delete one Tb_categoria.
     * @example
     * // Delete one Tb_categoria
     * const Tb_categoria = await prisma.tb_categoria.delete({
     *   where: {
     *     // ... filter to delete one Tb_categoria
     *   }
     * })
     * 
    **/
    delete<T extends Tb_categoriaDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_categoriaDeleteArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_categoria.
     * @param {Tb_categoriaUpdateArgs} args - Arguments to update one Tb_categoria.
     * @example
     * // Update one Tb_categoria
     * const tb_categoria = await prisma.tb_categoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Tb_categoriaUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_categoriaUpdateArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_categorias.
     * @param {Tb_categoriaDeleteManyArgs} args - Arguments to filter Tb_categorias to delete.
     * @example
     * // Delete a few Tb_categorias
     * const { count } = await prisma.tb_categoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Tb_categoriaDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_categoriaDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_categorias
     * const tb_categoria = await prisma.tb_categoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Tb_categoriaUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_categoriaUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_categoria.
     * @param {Tb_categoriaUpsertArgs} args - Arguments to update or create a Tb_categoria.
     * @example
     * // Update or create a Tb_categoria
     * const tb_categoria = await prisma.tb_categoria.upsert({
     *   create: {
     *     // ... data to create a Tb_categoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_categoria we want to update
     *   }
     * })
    **/
    upsert<T extends Tb_categoriaUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_categoriaUpsertArgs<ExtArgs>>
    ): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_categorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaCountArgs} args - Arguments to filter Tb_categorias to count.
     * @example
     * // Count the number of Tb_categorias
     * const count = await prisma.tb_categoria.count({
     *   where: {
     *     // ... the filter for the Tb_categorias we want to count
     *   }
     * })
    **/
    count<T extends Tb_categoriaCountArgs>(
      args?: Subset<T, Tb_categoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_categoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_categoriaAggregateArgs>(args: Subset<T, Tb_categoriaAggregateArgs>): Prisma.PrismaPromise<GetTb_categoriaAggregateType<T>>

    /**
     * Group by Tb_categoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_categoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tb_categoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tb_categoriaGroupByArgs['orderBy'] }
        : { orderBy?: Tb_categoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tb_categoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_categoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tb_categoria model
   */
  readonly fields: Tb_categoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tb_categoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tb_categoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    pergunta<T extends Tb_categoria$perguntaArgs<ExtArgs> = {}>(args?: Subset<T, Tb_categoria$perguntaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tb_categoria model
   */ 
  interface Tb_categoriaFieldRefs {
    readonly idCat: FieldRef<"Tb_categoria", 'Int'>
    readonly nomeCat: FieldRef<"Tb_categoria", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tb_categoria findUnique
   */
  export type Tb_categoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * Filter, which Tb_categoria to fetch.
     */
    where: Tb_categoriaWhereUniqueInput
  }


  /**
   * Tb_categoria findUniqueOrThrow
   */
  export type Tb_categoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * Filter, which Tb_categoria to fetch.
     */
    where: Tb_categoriaWhereUniqueInput
  }


  /**
   * Tb_categoria findFirst
   */
  export type Tb_categoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * Filter, which Tb_categoria to fetch.
     */
    where?: Tb_categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_categorias to fetch.
     */
    orderBy?: Tb_categoriaOrderByWithRelationInput | Tb_categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_categorias.
     */
    cursor?: Tb_categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_categorias.
     */
    distinct?: Tb_categoriaScalarFieldEnum | Tb_categoriaScalarFieldEnum[]
  }


  /**
   * Tb_categoria findFirstOrThrow
   */
  export type Tb_categoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * Filter, which Tb_categoria to fetch.
     */
    where?: Tb_categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_categorias to fetch.
     */
    orderBy?: Tb_categoriaOrderByWithRelationInput | Tb_categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_categorias.
     */
    cursor?: Tb_categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_categorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_categorias.
     */
    distinct?: Tb_categoriaScalarFieldEnum | Tb_categoriaScalarFieldEnum[]
  }


  /**
   * Tb_categoria findMany
   */
  export type Tb_categoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * Filter, which Tb_categorias to fetch.
     */
    where?: Tb_categoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_categorias to fetch.
     */
    orderBy?: Tb_categoriaOrderByWithRelationInput | Tb_categoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tb_categorias.
     */
    cursor?: Tb_categoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_categorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_categorias.
     */
    skip?: number
    distinct?: Tb_categoriaScalarFieldEnum | Tb_categoriaScalarFieldEnum[]
  }


  /**
   * Tb_categoria create
   */
  export type Tb_categoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a Tb_categoria.
     */
    data: XOR<Tb_categoriaCreateInput, Tb_categoriaUncheckedCreateInput>
  }


  /**
   * Tb_categoria createMany
   */
  export type Tb_categoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tb_categorias.
     */
    data: Tb_categoriaCreateManyInput | Tb_categoriaCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tb_categoria update
   */
  export type Tb_categoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a Tb_categoria.
     */
    data: XOR<Tb_categoriaUpdateInput, Tb_categoriaUncheckedUpdateInput>
    /**
     * Choose, which Tb_categoria to update.
     */
    where: Tb_categoriaWhereUniqueInput
  }


  /**
   * Tb_categoria updateMany
   */
  export type Tb_categoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tb_categorias.
     */
    data: XOR<Tb_categoriaUpdateManyMutationInput, Tb_categoriaUncheckedUpdateManyInput>
    /**
     * Filter which Tb_categorias to update
     */
    where?: Tb_categoriaWhereInput
  }


  /**
   * Tb_categoria upsert
   */
  export type Tb_categoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the Tb_categoria to update in case it exists.
     */
    where: Tb_categoriaWhereUniqueInput
    /**
     * In case the Tb_categoria found by the `where` argument doesn't exist, create a new Tb_categoria with this data.
     */
    create: XOR<Tb_categoriaCreateInput, Tb_categoriaUncheckedCreateInput>
    /**
     * In case the Tb_categoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tb_categoriaUpdateInput, Tb_categoriaUncheckedUpdateInput>
  }


  /**
   * Tb_categoria delete
   */
  export type Tb_categoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
    /**
     * Filter which Tb_categoria to delete.
     */
    where: Tb_categoriaWhereUniqueInput
  }


  /**
   * Tb_categoria deleteMany
   */
  export type Tb_categoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_categorias to delete
     */
    where?: Tb_categoriaWhereInput
  }


  /**
   * Tb_categoria.pergunta
   */
  export type Tb_categoria$perguntaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    where?: Tb_perguntasWhereInput
    orderBy?: Tb_perguntasOrderByWithRelationInput | Tb_perguntasOrderByWithRelationInput[]
    cursor?: Tb_perguntasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_perguntasScalarFieldEnum | Tb_perguntasScalarFieldEnum[]
  }


  /**
   * Tb_categoria without action
   */
  export type Tb_categoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_categoria
     */
    select?: Tb_categoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_categoriaInclude<ExtArgs> | null
  }



  /**
   * Model Tb_perguntas
   */

  export type AggregateTb_perguntas = {
    _count: Tb_perguntasCountAggregateOutputType | null
    _avg: Tb_perguntasAvgAggregateOutputType | null
    _sum: Tb_perguntasSumAggregateOutputType | null
    _min: Tb_perguntasMinAggregateOutputType | null
    _max: Tb_perguntasMaxAggregateOutputType | null
  }

  export type Tb_perguntasAvgAggregateOutputType = {
    idPer: number | null
    idCat: number | null
    idUsu: number | null
  }

  export type Tb_perguntasSumAggregateOutputType = {
    idPer: number | null
    idCat: number | null
    idUsu: number | null
  }

  export type Tb_perguntasMinAggregateOutputType = {
    idPer: number | null
    idCat: number | null
    idUsu: number | null
    tituloPer: string | null
    conteudoPer: string | null
  }

  export type Tb_perguntasMaxAggregateOutputType = {
    idPer: number | null
    idCat: number | null
    idUsu: number | null
    tituloPer: string | null
    conteudoPer: string | null
  }

  export type Tb_perguntasCountAggregateOutputType = {
    idPer: number
    idCat: number
    idUsu: number
    tituloPer: number
    conteudoPer: number
    _all: number
  }


  export type Tb_perguntasAvgAggregateInputType = {
    idPer?: true
    idCat?: true
    idUsu?: true
  }

  export type Tb_perguntasSumAggregateInputType = {
    idPer?: true
    idCat?: true
    idUsu?: true
  }

  export type Tb_perguntasMinAggregateInputType = {
    idPer?: true
    idCat?: true
    idUsu?: true
    tituloPer?: true
    conteudoPer?: true
  }

  export type Tb_perguntasMaxAggregateInputType = {
    idPer?: true
    idCat?: true
    idUsu?: true
    tituloPer?: true
    conteudoPer?: true
  }

  export type Tb_perguntasCountAggregateInputType = {
    idPer?: true
    idCat?: true
    idUsu?: true
    tituloPer?: true
    conteudoPer?: true
    _all?: true
  }

  export type Tb_perguntasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_perguntas to aggregate.
     */
    where?: Tb_perguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_perguntas to fetch.
     */
    orderBy?: Tb_perguntasOrderByWithRelationInput | Tb_perguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tb_perguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_perguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_perguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tb_perguntas
    **/
    _count?: true | Tb_perguntasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_perguntasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_perguntasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_perguntasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_perguntasMaxAggregateInputType
  }

  export type GetTb_perguntasAggregateType<T extends Tb_perguntasAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_perguntas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_perguntas[P]>
      : GetScalarType<T[P], AggregateTb_perguntas[P]>
  }




  export type Tb_perguntasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_perguntasWhereInput
    orderBy?: Tb_perguntasOrderByWithAggregationInput | Tb_perguntasOrderByWithAggregationInput[]
    by: Tb_perguntasScalarFieldEnum[] | Tb_perguntasScalarFieldEnum
    having?: Tb_perguntasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_perguntasCountAggregateInputType | true
    _avg?: Tb_perguntasAvgAggregateInputType
    _sum?: Tb_perguntasSumAggregateInputType
    _min?: Tb_perguntasMinAggregateInputType
    _max?: Tb_perguntasMaxAggregateInputType
  }

  export type Tb_perguntasGroupByOutputType = {
    idPer: number
    idCat: number
    idUsu: number
    tituloPer: string
    conteudoPer: string
    _count: Tb_perguntasCountAggregateOutputType | null
    _avg: Tb_perguntasAvgAggregateOutputType | null
    _sum: Tb_perguntasSumAggregateOutputType | null
    _min: Tb_perguntasMinAggregateOutputType | null
    _max: Tb_perguntasMaxAggregateOutputType | null
  }

  type GetTb_perguntasGroupByPayload<T extends Tb_perguntasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_perguntasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_perguntasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_perguntasGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_perguntasGroupByOutputType[P]>
        }
      >
    >


  export type Tb_perguntasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPer?: boolean
    idCat?: boolean
    idUsu?: boolean
    tituloPer?: boolean
    conteudoPer?: boolean
    categorias?: boolean | Tb_categoriaDefaultArgs<ExtArgs>
    usuarios?: boolean | Tb_usuariosDefaultArgs<ExtArgs>
    respostas?: boolean | Tb_perguntas$respostasArgs<ExtArgs>
    _count?: boolean | Tb_perguntasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_perguntas"]>

  export type Tb_perguntasSelectScalar = {
    idPer?: boolean
    idCat?: boolean
    idUsu?: boolean
    tituloPer?: boolean
    conteudoPer?: boolean
  }

  export type Tb_perguntasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categorias?: boolean | Tb_categoriaDefaultArgs<ExtArgs>
    usuarios?: boolean | Tb_usuariosDefaultArgs<ExtArgs>
    respostas?: boolean | Tb_perguntas$respostasArgs<ExtArgs>
    _count?: boolean | Tb_perguntasCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $Tb_perguntasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tb_perguntas"
    objects: {
      categorias: Prisma.$Tb_categoriaPayload<ExtArgs>
      usuarios: Prisma.$Tb_usuariosPayload<ExtArgs>
      respostas: Prisma.$Tb_respostasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPer: number
      idCat: number
      idUsu: number
      tituloPer: string
      conteudoPer: string
    }, ExtArgs["result"]["tb_perguntas"]>
    composites: {}
  }


  type Tb_perguntasGetPayload<S extends boolean | null | undefined | Tb_perguntasDefaultArgs> = $Result.GetResult<Prisma.$Tb_perguntasPayload, S>

  type Tb_perguntasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tb_perguntasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tb_perguntasCountAggregateInputType | true
    }

  export interface Tb_perguntasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tb_perguntas'], meta: { name: 'Tb_perguntas' } }
    /**
     * Find zero or one Tb_perguntas that matches the filter.
     * @param {Tb_perguntasFindUniqueArgs} args - Arguments to find a Tb_perguntas
     * @example
     * // Get one Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Tb_perguntasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_perguntasFindUniqueArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_perguntas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Tb_perguntasFindUniqueOrThrowArgs} args - Arguments to find a Tb_perguntas
     * @example
     * // Get one Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Tb_perguntasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_perguntasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_perguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasFindFirstArgs} args - Arguments to find a Tb_perguntas
     * @example
     * // Get one Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Tb_perguntasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_perguntasFindFirstArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_perguntas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasFindFirstOrThrowArgs} args - Arguments to find a Tb_perguntas
     * @example
     * // Get one Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Tb_perguntasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_perguntasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_perguntas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.findMany()
     * 
     * // Get first 10 Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.findMany({ take: 10 })
     * 
     * // Only select the `idPer`
     * const tb_perguntasWithIdPerOnly = await prisma.tb_perguntas.findMany({ select: { idPer: true } })
     * 
    **/
    findMany<T extends Tb_perguntasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_perguntasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_perguntas.
     * @param {Tb_perguntasCreateArgs} args - Arguments to create a Tb_perguntas.
     * @example
     * // Create one Tb_perguntas
     * const Tb_perguntas = await prisma.tb_perguntas.create({
     *   data: {
     *     // ... data to create a Tb_perguntas
     *   }
     * })
     * 
    **/
    create<T extends Tb_perguntasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_perguntasCreateArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_perguntas.
     *     @param {Tb_perguntasCreateManyArgs} args - Arguments to create many Tb_perguntas.
     *     @example
     *     // Create many Tb_perguntas
     *     const tb_perguntas = await prisma.tb_perguntas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Tb_perguntasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_perguntasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_perguntas.
     * @param {Tb_perguntasDeleteArgs} args - Arguments to delete one Tb_perguntas.
     * @example
     * // Delete one Tb_perguntas
     * const Tb_perguntas = await prisma.tb_perguntas.delete({
     *   where: {
     *     // ... filter to delete one Tb_perguntas
     *   }
     * })
     * 
    **/
    delete<T extends Tb_perguntasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_perguntasDeleteArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_perguntas.
     * @param {Tb_perguntasUpdateArgs} args - Arguments to update one Tb_perguntas.
     * @example
     * // Update one Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Tb_perguntasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_perguntasUpdateArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_perguntas.
     * @param {Tb_perguntasDeleteManyArgs} args - Arguments to filter Tb_perguntas to delete.
     * @example
     * // Delete a few Tb_perguntas
     * const { count } = await prisma.tb_perguntas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Tb_perguntasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_perguntasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_perguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Tb_perguntasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_perguntasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_perguntas.
     * @param {Tb_perguntasUpsertArgs} args - Arguments to update or create a Tb_perguntas.
     * @example
     * // Update or create a Tb_perguntas
     * const tb_perguntas = await prisma.tb_perguntas.upsert({
     *   create: {
     *     // ... data to create a Tb_perguntas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_perguntas we want to update
     *   }
     * })
    **/
    upsert<T extends Tb_perguntasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_perguntasUpsertArgs<ExtArgs>>
    ): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_perguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasCountArgs} args - Arguments to filter Tb_perguntas to count.
     * @example
     * // Count the number of Tb_perguntas
     * const count = await prisma.tb_perguntas.count({
     *   where: {
     *     // ... the filter for the Tb_perguntas we want to count
     *   }
     * })
    **/
    count<T extends Tb_perguntasCountArgs>(
      args?: Subset<T, Tb_perguntasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_perguntasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_perguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_perguntasAggregateArgs>(args: Subset<T, Tb_perguntasAggregateArgs>): Prisma.PrismaPromise<GetTb_perguntasAggregateType<T>>

    /**
     * Group by Tb_perguntas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_perguntasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tb_perguntasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tb_perguntasGroupByArgs['orderBy'] }
        : { orderBy?: Tb_perguntasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tb_perguntasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_perguntasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tb_perguntas model
   */
  readonly fields: Tb_perguntasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tb_perguntas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tb_perguntasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    categorias<T extends Tb_categoriaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tb_categoriaDefaultArgs<ExtArgs>>): Prisma__Tb_categoriaClient<$Result.GetResult<Prisma.$Tb_categoriaPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuarios<T extends Tb_usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tb_usuariosDefaultArgs<ExtArgs>>): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    respostas<T extends Tb_perguntas$respostasArgs<ExtArgs> = {}>(args?: Subset<T, Tb_perguntas$respostasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tb_perguntas model
   */ 
  interface Tb_perguntasFieldRefs {
    readonly idPer: FieldRef<"Tb_perguntas", 'Int'>
    readonly idCat: FieldRef<"Tb_perguntas", 'Int'>
    readonly idUsu: FieldRef<"Tb_perguntas", 'Int'>
    readonly tituloPer: FieldRef<"Tb_perguntas", 'String'>
    readonly conteudoPer: FieldRef<"Tb_perguntas", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tb_perguntas findUnique
   */
  export type Tb_perguntasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_perguntas to fetch.
     */
    where: Tb_perguntasWhereUniqueInput
  }


  /**
   * Tb_perguntas findUniqueOrThrow
   */
  export type Tb_perguntasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_perguntas to fetch.
     */
    where: Tb_perguntasWhereUniqueInput
  }


  /**
   * Tb_perguntas findFirst
   */
  export type Tb_perguntasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_perguntas to fetch.
     */
    where?: Tb_perguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_perguntas to fetch.
     */
    orderBy?: Tb_perguntasOrderByWithRelationInput | Tb_perguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_perguntas.
     */
    cursor?: Tb_perguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_perguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_perguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_perguntas.
     */
    distinct?: Tb_perguntasScalarFieldEnum | Tb_perguntasScalarFieldEnum[]
  }


  /**
   * Tb_perguntas findFirstOrThrow
   */
  export type Tb_perguntasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_perguntas to fetch.
     */
    where?: Tb_perguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_perguntas to fetch.
     */
    orderBy?: Tb_perguntasOrderByWithRelationInput | Tb_perguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_perguntas.
     */
    cursor?: Tb_perguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_perguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_perguntas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_perguntas.
     */
    distinct?: Tb_perguntasScalarFieldEnum | Tb_perguntasScalarFieldEnum[]
  }


  /**
   * Tb_perguntas findMany
   */
  export type Tb_perguntasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_perguntas to fetch.
     */
    where?: Tb_perguntasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_perguntas to fetch.
     */
    orderBy?: Tb_perguntasOrderByWithRelationInput | Tb_perguntasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tb_perguntas.
     */
    cursor?: Tb_perguntasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_perguntas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_perguntas.
     */
    skip?: number
    distinct?: Tb_perguntasScalarFieldEnum | Tb_perguntasScalarFieldEnum[]
  }


  /**
   * Tb_perguntas create
   */
  export type Tb_perguntasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * The data needed to create a Tb_perguntas.
     */
    data: XOR<Tb_perguntasCreateInput, Tb_perguntasUncheckedCreateInput>
  }


  /**
   * Tb_perguntas createMany
   */
  export type Tb_perguntasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tb_perguntas.
     */
    data: Tb_perguntasCreateManyInput | Tb_perguntasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tb_perguntas update
   */
  export type Tb_perguntasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * The data needed to update a Tb_perguntas.
     */
    data: XOR<Tb_perguntasUpdateInput, Tb_perguntasUncheckedUpdateInput>
    /**
     * Choose, which Tb_perguntas to update.
     */
    where: Tb_perguntasWhereUniqueInput
  }


  /**
   * Tb_perguntas updateMany
   */
  export type Tb_perguntasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tb_perguntas.
     */
    data: XOR<Tb_perguntasUpdateManyMutationInput, Tb_perguntasUncheckedUpdateManyInput>
    /**
     * Filter which Tb_perguntas to update
     */
    where?: Tb_perguntasWhereInput
  }


  /**
   * Tb_perguntas upsert
   */
  export type Tb_perguntasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * The filter to search for the Tb_perguntas to update in case it exists.
     */
    where: Tb_perguntasWhereUniqueInput
    /**
     * In case the Tb_perguntas found by the `where` argument doesn't exist, create a new Tb_perguntas with this data.
     */
    create: XOR<Tb_perguntasCreateInput, Tb_perguntasUncheckedCreateInput>
    /**
     * In case the Tb_perguntas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tb_perguntasUpdateInput, Tb_perguntasUncheckedUpdateInput>
  }


  /**
   * Tb_perguntas delete
   */
  export type Tb_perguntasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
    /**
     * Filter which Tb_perguntas to delete.
     */
    where: Tb_perguntasWhereUniqueInput
  }


  /**
   * Tb_perguntas deleteMany
   */
  export type Tb_perguntasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_perguntas to delete
     */
    where?: Tb_perguntasWhereInput
  }


  /**
   * Tb_perguntas.respostas
   */
  export type Tb_perguntas$respostasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    where?: Tb_respostasWhereInput
    orderBy?: Tb_respostasOrderByWithRelationInput | Tb_respostasOrderByWithRelationInput[]
    cursor?: Tb_respostasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tb_respostasScalarFieldEnum | Tb_respostasScalarFieldEnum[]
  }


  /**
   * Tb_perguntas without action
   */
  export type Tb_perguntasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_perguntas
     */
    select?: Tb_perguntasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_perguntasInclude<ExtArgs> | null
  }



  /**
   * Model Tb_respostas
   */

  export type AggregateTb_respostas = {
    _count: Tb_respostasCountAggregateOutputType | null
    _avg: Tb_respostasAvgAggregateOutputType | null
    _sum: Tb_respostasSumAggregateOutputType | null
    _min: Tb_respostasMinAggregateOutputType | null
    _max: Tb_respostasMaxAggregateOutputType | null
  }

  export type Tb_respostasAvgAggregateOutputType = {
    idRes: number | null
    idPer: number | null
    idUsu: number | null
  }

  export type Tb_respostasSumAggregateOutputType = {
    idRes: number | null
    idPer: number | null
    idUsu: number | null
  }

  export type Tb_respostasMinAggregateOutputType = {
    idRes: number | null
    idPer: number | null
    idUsu: number | null
    conteudoRes: string | null
  }

  export type Tb_respostasMaxAggregateOutputType = {
    idRes: number | null
    idPer: number | null
    idUsu: number | null
    conteudoRes: string | null
  }

  export type Tb_respostasCountAggregateOutputType = {
    idRes: number
    idPer: number
    idUsu: number
    conteudoRes: number
    _all: number
  }


  export type Tb_respostasAvgAggregateInputType = {
    idRes?: true
    idPer?: true
    idUsu?: true
  }

  export type Tb_respostasSumAggregateInputType = {
    idRes?: true
    idPer?: true
    idUsu?: true
  }

  export type Tb_respostasMinAggregateInputType = {
    idRes?: true
    idPer?: true
    idUsu?: true
    conteudoRes?: true
  }

  export type Tb_respostasMaxAggregateInputType = {
    idRes?: true
    idPer?: true
    idUsu?: true
    conteudoRes?: true
  }

  export type Tb_respostasCountAggregateInputType = {
    idRes?: true
    idPer?: true
    idUsu?: true
    conteudoRes?: true
    _all?: true
  }

  export type Tb_respostasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_respostas to aggregate.
     */
    where?: Tb_respostasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_respostas to fetch.
     */
    orderBy?: Tb_respostasOrderByWithRelationInput | Tb_respostasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tb_respostasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_respostas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tb_respostas
    **/
    _count?: true | Tb_respostasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_respostasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_respostasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_respostasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_respostasMaxAggregateInputType
  }

  export type GetTb_respostasAggregateType<T extends Tb_respostasAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_respostas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_respostas[P]>
      : GetScalarType<T[P], AggregateTb_respostas[P]>
  }




  export type Tb_respostasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_respostasWhereInput
    orderBy?: Tb_respostasOrderByWithAggregationInput | Tb_respostasOrderByWithAggregationInput[]
    by: Tb_respostasScalarFieldEnum[] | Tb_respostasScalarFieldEnum
    having?: Tb_respostasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_respostasCountAggregateInputType | true
    _avg?: Tb_respostasAvgAggregateInputType
    _sum?: Tb_respostasSumAggregateInputType
    _min?: Tb_respostasMinAggregateInputType
    _max?: Tb_respostasMaxAggregateInputType
  }

  export type Tb_respostasGroupByOutputType = {
    idRes: number
    idPer: number
    idUsu: number
    conteudoRes: string
    _count: Tb_respostasCountAggregateOutputType | null
    _avg: Tb_respostasAvgAggregateOutputType | null
    _sum: Tb_respostasSumAggregateOutputType | null
    _min: Tb_respostasMinAggregateOutputType | null
    _max: Tb_respostasMaxAggregateOutputType | null
  }

  type GetTb_respostasGroupByPayload<T extends Tb_respostasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_respostasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_respostasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_respostasGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_respostasGroupByOutputType[P]>
        }
      >
    >


  export type Tb_respostasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idRes?: boolean
    idPer?: boolean
    idUsu?: boolean
    conteudoRes?: boolean
    perguntas?: boolean | Tb_perguntasDefaultArgs<ExtArgs>
    usuarios?: boolean | Tb_usuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_respostas"]>

  export type Tb_respostasSelectScalar = {
    idRes?: boolean
    idPer?: boolean
    idUsu?: boolean
    conteudoRes?: boolean
  }

  export type Tb_respostasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    perguntas?: boolean | Tb_perguntasDefaultArgs<ExtArgs>
    usuarios?: boolean | Tb_usuariosDefaultArgs<ExtArgs>
  }


  export type $Tb_respostasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tb_respostas"
    objects: {
      perguntas: Prisma.$Tb_perguntasPayload<ExtArgs>
      usuarios: Prisma.$Tb_usuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idRes: number
      idPer: number
      idUsu: number
      conteudoRes: string
    }, ExtArgs["result"]["tb_respostas"]>
    composites: {}
  }


  type Tb_respostasGetPayload<S extends boolean | null | undefined | Tb_respostasDefaultArgs> = $Result.GetResult<Prisma.$Tb_respostasPayload, S>

  type Tb_respostasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tb_respostasFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tb_respostasCountAggregateInputType | true
    }

  export interface Tb_respostasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tb_respostas'], meta: { name: 'Tb_respostas' } }
    /**
     * Find zero or one Tb_respostas that matches the filter.
     * @param {Tb_respostasFindUniqueArgs} args - Arguments to find a Tb_respostas
     * @example
     * // Get one Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Tb_respostasFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_respostasFindUniqueArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_respostas that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Tb_respostasFindUniqueOrThrowArgs} args - Arguments to find a Tb_respostas
     * @example
     * // Get one Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Tb_respostasFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_respostasFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_respostas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasFindFirstArgs} args - Arguments to find a Tb_respostas
     * @example
     * // Get one Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Tb_respostasFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_respostasFindFirstArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_respostas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasFindFirstOrThrowArgs} args - Arguments to find a Tb_respostas
     * @example
     * // Get one Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Tb_respostasFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_respostasFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_respostas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.findMany()
     * 
     * // Get first 10 Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.findMany({ take: 10 })
     * 
     * // Only select the `idRes`
     * const tb_respostasWithIdResOnly = await prisma.tb_respostas.findMany({ select: { idRes: true } })
     * 
    **/
    findMany<T extends Tb_respostasFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_respostasFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_respostas.
     * @param {Tb_respostasCreateArgs} args - Arguments to create a Tb_respostas.
     * @example
     * // Create one Tb_respostas
     * const Tb_respostas = await prisma.tb_respostas.create({
     *   data: {
     *     // ... data to create a Tb_respostas
     *   }
     * })
     * 
    **/
    create<T extends Tb_respostasCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_respostasCreateArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_respostas.
     *     @param {Tb_respostasCreateManyArgs} args - Arguments to create many Tb_respostas.
     *     @example
     *     // Create many Tb_respostas
     *     const tb_respostas = await prisma.tb_respostas.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Tb_respostasCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_respostasCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_respostas.
     * @param {Tb_respostasDeleteArgs} args - Arguments to delete one Tb_respostas.
     * @example
     * // Delete one Tb_respostas
     * const Tb_respostas = await prisma.tb_respostas.delete({
     *   where: {
     *     // ... filter to delete one Tb_respostas
     *   }
     * })
     * 
    **/
    delete<T extends Tb_respostasDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_respostasDeleteArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_respostas.
     * @param {Tb_respostasUpdateArgs} args - Arguments to update one Tb_respostas.
     * @example
     * // Update one Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Tb_respostasUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_respostasUpdateArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_respostas.
     * @param {Tb_respostasDeleteManyArgs} args - Arguments to filter Tb_respostas to delete.
     * @example
     * // Delete a few Tb_respostas
     * const { count } = await prisma.tb_respostas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Tb_respostasDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_respostasDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_respostas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Tb_respostasUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_respostasUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_respostas.
     * @param {Tb_respostasUpsertArgs} args - Arguments to update or create a Tb_respostas.
     * @example
     * // Update or create a Tb_respostas
     * const tb_respostas = await prisma.tb_respostas.upsert({
     *   create: {
     *     // ... data to create a Tb_respostas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_respostas we want to update
     *   }
     * })
    **/
    upsert<T extends Tb_respostasUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_respostasUpsertArgs<ExtArgs>>
    ): Prisma__Tb_respostasClient<$Result.GetResult<Prisma.$Tb_respostasPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_respostas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasCountArgs} args - Arguments to filter Tb_respostas to count.
     * @example
     * // Count the number of Tb_respostas
     * const count = await prisma.tb_respostas.count({
     *   where: {
     *     // ... the filter for the Tb_respostas we want to count
     *   }
     * })
    **/
    count<T extends Tb_respostasCountArgs>(
      args?: Subset<T, Tb_respostasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_respostasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_respostas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_respostasAggregateArgs>(args: Subset<T, Tb_respostasAggregateArgs>): Prisma.PrismaPromise<GetTb_respostasAggregateType<T>>

    /**
     * Group by Tb_respostas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_respostasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tb_respostasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tb_respostasGroupByArgs['orderBy'] }
        : { orderBy?: Tb_respostasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tb_respostasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_respostasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tb_respostas model
   */
  readonly fields: Tb_respostasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tb_respostas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tb_respostasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    perguntas<T extends Tb_perguntasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tb_perguntasDefaultArgs<ExtArgs>>): Prisma__Tb_perguntasClient<$Result.GetResult<Prisma.$Tb_perguntasPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    usuarios<T extends Tb_usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tb_usuariosDefaultArgs<ExtArgs>>): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tb_respostas model
   */ 
  interface Tb_respostasFieldRefs {
    readonly idRes: FieldRef<"Tb_respostas", 'Int'>
    readonly idPer: FieldRef<"Tb_respostas", 'Int'>
    readonly idUsu: FieldRef<"Tb_respostas", 'Int'>
    readonly conteudoRes: FieldRef<"Tb_respostas", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tb_respostas findUnique
   */
  export type Tb_respostasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_respostas to fetch.
     */
    where: Tb_respostasWhereUniqueInput
  }


  /**
   * Tb_respostas findUniqueOrThrow
   */
  export type Tb_respostasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_respostas to fetch.
     */
    where: Tb_respostasWhereUniqueInput
  }


  /**
   * Tb_respostas findFirst
   */
  export type Tb_respostasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_respostas to fetch.
     */
    where?: Tb_respostasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_respostas to fetch.
     */
    orderBy?: Tb_respostasOrderByWithRelationInput | Tb_respostasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_respostas.
     */
    cursor?: Tb_respostasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_respostas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_respostas.
     */
    distinct?: Tb_respostasScalarFieldEnum | Tb_respostasScalarFieldEnum[]
  }


  /**
   * Tb_respostas findFirstOrThrow
   */
  export type Tb_respostasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_respostas to fetch.
     */
    where?: Tb_respostasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_respostas to fetch.
     */
    orderBy?: Tb_respostasOrderByWithRelationInput | Tb_respostasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_respostas.
     */
    cursor?: Tb_respostasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_respostas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_respostas.
     */
    distinct?: Tb_respostasScalarFieldEnum | Tb_respostasScalarFieldEnum[]
  }


  /**
   * Tb_respostas findMany
   */
  export type Tb_respostasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * Filter, which Tb_respostas to fetch.
     */
    where?: Tb_respostasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_respostas to fetch.
     */
    orderBy?: Tb_respostasOrderByWithRelationInput | Tb_respostasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tb_respostas.
     */
    cursor?: Tb_respostasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_respostas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_respostas.
     */
    skip?: number
    distinct?: Tb_respostasScalarFieldEnum | Tb_respostasScalarFieldEnum[]
  }


  /**
   * Tb_respostas create
   */
  export type Tb_respostasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * The data needed to create a Tb_respostas.
     */
    data: XOR<Tb_respostasCreateInput, Tb_respostasUncheckedCreateInput>
  }


  /**
   * Tb_respostas createMany
   */
  export type Tb_respostasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tb_respostas.
     */
    data: Tb_respostasCreateManyInput | Tb_respostasCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tb_respostas update
   */
  export type Tb_respostasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * The data needed to update a Tb_respostas.
     */
    data: XOR<Tb_respostasUpdateInput, Tb_respostasUncheckedUpdateInput>
    /**
     * Choose, which Tb_respostas to update.
     */
    where: Tb_respostasWhereUniqueInput
  }


  /**
   * Tb_respostas updateMany
   */
  export type Tb_respostasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tb_respostas.
     */
    data: XOR<Tb_respostasUpdateManyMutationInput, Tb_respostasUncheckedUpdateManyInput>
    /**
     * Filter which Tb_respostas to update
     */
    where?: Tb_respostasWhereInput
  }


  /**
   * Tb_respostas upsert
   */
  export type Tb_respostasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * The filter to search for the Tb_respostas to update in case it exists.
     */
    where: Tb_respostasWhereUniqueInput
    /**
     * In case the Tb_respostas found by the `where` argument doesn't exist, create a new Tb_respostas with this data.
     */
    create: XOR<Tb_respostasCreateInput, Tb_respostasUncheckedCreateInput>
    /**
     * In case the Tb_respostas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tb_respostasUpdateInput, Tb_respostasUncheckedUpdateInput>
  }


  /**
   * Tb_respostas delete
   */
  export type Tb_respostasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
    /**
     * Filter which Tb_respostas to delete.
     */
    where: Tb_respostasWhereUniqueInput
  }


  /**
   * Tb_respostas deleteMany
   */
  export type Tb_respostasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_respostas to delete
     */
    where?: Tb_respostasWhereInput
  }


  /**
   * Tb_respostas without action
   */
  export type Tb_respostasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_respostas
     */
    select?: Tb_respostasSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_respostasInclude<ExtArgs> | null
  }



  /**
   * Model Tb_avaliacoes
   */

  export type AggregateTb_avaliacoes = {
    _count: Tb_avaliacoesCountAggregateOutputType | null
    _avg: Tb_avaliacoesAvgAggregateOutputType | null
    _sum: Tb_avaliacoesSumAggregateOutputType | null
    _min: Tb_avaliacoesMinAggregateOutputType | null
    _max: Tb_avaliacoesMaxAggregateOutputType | null
  }

  export type Tb_avaliacoesAvgAggregateOutputType = {
    idAva: number | null
    idUsuAva: number | null
    idPost: number | null
  }

  export type Tb_avaliacoesSumAggregateOutputType = {
    idAva: number | null
    idUsuAva: number | null
    idPost: number | null
  }

  export type Tb_avaliacoesMinAggregateOutputType = {
    idAva: number | null
    idUsuAva: number | null
    tipoAva: string | null
    idPost: number | null
    tipoPost: string | null
  }

  export type Tb_avaliacoesMaxAggregateOutputType = {
    idAva: number | null
    idUsuAva: number | null
    tipoAva: string | null
    idPost: number | null
    tipoPost: string | null
  }

  export type Tb_avaliacoesCountAggregateOutputType = {
    idAva: number
    idUsuAva: number
    tipoAva: number
    idPost: number
    tipoPost: number
    _all: number
  }


  export type Tb_avaliacoesAvgAggregateInputType = {
    idAva?: true
    idUsuAva?: true
    idPost?: true
  }

  export type Tb_avaliacoesSumAggregateInputType = {
    idAva?: true
    idUsuAva?: true
    idPost?: true
  }

  export type Tb_avaliacoesMinAggregateInputType = {
    idAva?: true
    idUsuAva?: true
    tipoAva?: true
    idPost?: true
    tipoPost?: true
  }

  export type Tb_avaliacoesMaxAggregateInputType = {
    idAva?: true
    idUsuAva?: true
    tipoAva?: true
    idPost?: true
    tipoPost?: true
  }

  export type Tb_avaliacoesCountAggregateInputType = {
    idAva?: true
    idUsuAva?: true
    tipoAva?: true
    idPost?: true
    tipoPost?: true
    _all?: true
  }

  export type Tb_avaliacoesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_avaliacoes to aggregate.
     */
    where?: Tb_avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_avaliacoes to fetch.
     */
    orderBy?: Tb_avaliacoesOrderByWithRelationInput | Tb_avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Tb_avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_avaliacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tb_avaliacoes
    **/
    _count?: true | Tb_avaliacoesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tb_avaliacoesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tb_avaliacoesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tb_avaliacoesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tb_avaliacoesMaxAggregateInputType
  }

  export type GetTb_avaliacoesAggregateType<T extends Tb_avaliacoesAggregateArgs> = {
        [P in keyof T & keyof AggregateTb_avaliacoes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTb_avaliacoes[P]>
      : GetScalarType<T[P], AggregateTb_avaliacoes[P]>
  }




  export type Tb_avaliacoesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Tb_avaliacoesWhereInput
    orderBy?: Tb_avaliacoesOrderByWithAggregationInput | Tb_avaliacoesOrderByWithAggregationInput[]
    by: Tb_avaliacoesScalarFieldEnum[] | Tb_avaliacoesScalarFieldEnum
    having?: Tb_avaliacoesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tb_avaliacoesCountAggregateInputType | true
    _avg?: Tb_avaliacoesAvgAggregateInputType
    _sum?: Tb_avaliacoesSumAggregateInputType
    _min?: Tb_avaliacoesMinAggregateInputType
    _max?: Tb_avaliacoesMaxAggregateInputType
  }

  export type Tb_avaliacoesGroupByOutputType = {
    idAva: number
    idUsuAva: number
    tipoAva: string
    idPost: number
    tipoPost: string
    _count: Tb_avaliacoesCountAggregateOutputType | null
    _avg: Tb_avaliacoesAvgAggregateOutputType | null
    _sum: Tb_avaliacoesSumAggregateOutputType | null
    _min: Tb_avaliacoesMinAggregateOutputType | null
    _max: Tb_avaliacoesMaxAggregateOutputType | null
  }

  type GetTb_avaliacoesGroupByPayload<T extends Tb_avaliacoesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tb_avaliacoesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tb_avaliacoesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tb_avaliacoesGroupByOutputType[P]>
            : GetScalarType<T[P], Tb_avaliacoesGroupByOutputType[P]>
        }
      >
    >


  export type Tb_avaliacoesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idAva?: boolean
    idUsuAva?: boolean
    tipoAva?: boolean
    idPost?: boolean
    tipoPost?: boolean
    usuarios?: boolean | Tb_usuariosDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tb_avaliacoes"]>

  export type Tb_avaliacoesSelectScalar = {
    idAva?: boolean
    idUsuAva?: boolean
    tipoAva?: boolean
    idPost?: boolean
    tipoPost?: boolean
  }

  export type Tb_avaliacoesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuarios?: boolean | Tb_usuariosDefaultArgs<ExtArgs>
  }


  export type $Tb_avaliacoesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tb_avaliacoes"
    objects: {
      usuarios: Prisma.$Tb_usuariosPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idAva: number
      idUsuAva: number
      tipoAva: string
      idPost: number
      tipoPost: string
    }, ExtArgs["result"]["tb_avaliacoes"]>
    composites: {}
  }


  type Tb_avaliacoesGetPayload<S extends boolean | null | undefined | Tb_avaliacoesDefaultArgs> = $Result.GetResult<Prisma.$Tb_avaliacoesPayload, S>

  type Tb_avaliacoesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Tb_avaliacoesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Tb_avaliacoesCountAggregateInputType | true
    }

  export interface Tb_avaliacoesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tb_avaliacoes'], meta: { name: 'Tb_avaliacoes' } }
    /**
     * Find zero or one Tb_avaliacoes that matches the filter.
     * @param {Tb_avaliacoesFindUniqueArgs} args - Arguments to find a Tb_avaliacoes
     * @example
     * // Get one Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Tb_avaliacoesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_avaliacoesFindUniqueArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Tb_avaliacoes that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Tb_avaliacoesFindUniqueOrThrowArgs} args - Arguments to find a Tb_avaliacoes
     * @example
     * // Get one Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Tb_avaliacoesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_avaliacoesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Tb_avaliacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesFindFirstArgs} args - Arguments to find a Tb_avaliacoes
     * @example
     * // Get one Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Tb_avaliacoesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_avaliacoesFindFirstArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Tb_avaliacoes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesFindFirstOrThrowArgs} args - Arguments to find a Tb_avaliacoes
     * @example
     * // Get one Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Tb_avaliacoesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_avaliacoesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Tb_avaliacoes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.findMany()
     * 
     * // Get first 10 Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.findMany({ take: 10 })
     * 
     * // Only select the `idAva`
     * const tb_avaliacoesWithIdAvaOnly = await prisma.tb_avaliacoes.findMany({ select: { idAva: true } })
     * 
    **/
    findMany<T extends Tb_avaliacoesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_avaliacoesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Tb_avaliacoes.
     * @param {Tb_avaliacoesCreateArgs} args - Arguments to create a Tb_avaliacoes.
     * @example
     * // Create one Tb_avaliacoes
     * const Tb_avaliacoes = await prisma.tb_avaliacoes.create({
     *   data: {
     *     // ... data to create a Tb_avaliacoes
     *   }
     * })
     * 
    **/
    create<T extends Tb_avaliacoesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_avaliacoesCreateArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Tb_avaliacoes.
     *     @param {Tb_avaliacoesCreateManyArgs} args - Arguments to create many Tb_avaliacoes.
     *     @example
     *     // Create many Tb_avaliacoes
     *     const tb_avaliacoes = await prisma.tb_avaliacoes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Tb_avaliacoesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_avaliacoesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tb_avaliacoes.
     * @param {Tb_avaliacoesDeleteArgs} args - Arguments to delete one Tb_avaliacoes.
     * @example
     * // Delete one Tb_avaliacoes
     * const Tb_avaliacoes = await prisma.tb_avaliacoes.delete({
     *   where: {
     *     // ... filter to delete one Tb_avaliacoes
     *   }
     * })
     * 
    **/
    delete<T extends Tb_avaliacoesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_avaliacoesDeleteArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Tb_avaliacoes.
     * @param {Tb_avaliacoesUpdateArgs} args - Arguments to update one Tb_avaliacoes.
     * @example
     * // Update one Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Tb_avaliacoesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_avaliacoesUpdateArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Tb_avaliacoes.
     * @param {Tb_avaliacoesDeleteManyArgs} args - Arguments to filter Tb_avaliacoes to delete.
     * @example
     * // Delete a few Tb_avaliacoes
     * const { count } = await prisma.tb_avaliacoes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Tb_avaliacoesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Tb_avaliacoesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tb_avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Tb_avaliacoesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_avaliacoesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tb_avaliacoes.
     * @param {Tb_avaliacoesUpsertArgs} args - Arguments to update or create a Tb_avaliacoes.
     * @example
     * // Update or create a Tb_avaliacoes
     * const tb_avaliacoes = await prisma.tb_avaliacoes.upsert({
     *   create: {
     *     // ... data to create a Tb_avaliacoes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tb_avaliacoes we want to update
     *   }
     * })
    **/
    upsert<T extends Tb_avaliacoesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Tb_avaliacoesUpsertArgs<ExtArgs>>
    ): Prisma__Tb_avaliacoesClient<$Result.GetResult<Prisma.$Tb_avaliacoesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Tb_avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesCountArgs} args - Arguments to filter Tb_avaliacoes to count.
     * @example
     * // Count the number of Tb_avaliacoes
     * const count = await prisma.tb_avaliacoes.count({
     *   where: {
     *     // ... the filter for the Tb_avaliacoes we want to count
     *   }
     * })
    **/
    count<T extends Tb_avaliacoesCountArgs>(
      args?: Subset<T, Tb_avaliacoesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tb_avaliacoesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tb_avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tb_avaliacoesAggregateArgs>(args: Subset<T, Tb_avaliacoesAggregateArgs>): Prisma.PrismaPromise<GetTb_avaliacoesAggregateType<T>>

    /**
     * Group by Tb_avaliacoes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tb_avaliacoesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tb_avaliacoesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tb_avaliacoesGroupByArgs['orderBy'] }
        : { orderBy?: Tb_avaliacoesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tb_avaliacoesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTb_avaliacoesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tb_avaliacoes model
   */
  readonly fields: Tb_avaliacoesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tb_avaliacoes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Tb_avaliacoesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    usuarios<T extends Tb_usuariosDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Tb_usuariosDefaultArgs<ExtArgs>>): Prisma__Tb_usuariosClient<$Result.GetResult<Prisma.$Tb_usuariosPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Tb_avaliacoes model
   */ 
  interface Tb_avaliacoesFieldRefs {
    readonly idAva: FieldRef<"Tb_avaliacoes", 'Int'>
    readonly idUsuAva: FieldRef<"Tb_avaliacoes", 'Int'>
    readonly tipoAva: FieldRef<"Tb_avaliacoes", 'String'>
    readonly idPost: FieldRef<"Tb_avaliacoes", 'Int'>
    readonly tipoPost: FieldRef<"Tb_avaliacoes", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Tb_avaliacoes findUnique
   */
  export type Tb_avaliacoesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * Filter, which Tb_avaliacoes to fetch.
     */
    where: Tb_avaliacoesWhereUniqueInput
  }


  /**
   * Tb_avaliacoes findUniqueOrThrow
   */
  export type Tb_avaliacoesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * Filter, which Tb_avaliacoes to fetch.
     */
    where: Tb_avaliacoesWhereUniqueInput
  }


  /**
   * Tb_avaliacoes findFirst
   */
  export type Tb_avaliacoesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * Filter, which Tb_avaliacoes to fetch.
     */
    where?: Tb_avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_avaliacoes to fetch.
     */
    orderBy?: Tb_avaliacoesOrderByWithRelationInput | Tb_avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_avaliacoes.
     */
    cursor?: Tb_avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_avaliacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_avaliacoes.
     */
    distinct?: Tb_avaliacoesScalarFieldEnum | Tb_avaliacoesScalarFieldEnum[]
  }


  /**
   * Tb_avaliacoes findFirstOrThrow
   */
  export type Tb_avaliacoesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * Filter, which Tb_avaliacoes to fetch.
     */
    where?: Tb_avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_avaliacoes to fetch.
     */
    orderBy?: Tb_avaliacoesOrderByWithRelationInput | Tb_avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tb_avaliacoes.
     */
    cursor?: Tb_avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_avaliacoes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tb_avaliacoes.
     */
    distinct?: Tb_avaliacoesScalarFieldEnum | Tb_avaliacoesScalarFieldEnum[]
  }


  /**
   * Tb_avaliacoes findMany
   */
  export type Tb_avaliacoesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * Filter, which Tb_avaliacoes to fetch.
     */
    where?: Tb_avaliacoesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tb_avaliacoes to fetch.
     */
    orderBy?: Tb_avaliacoesOrderByWithRelationInput | Tb_avaliacoesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tb_avaliacoes.
     */
    cursor?: Tb_avaliacoesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tb_avaliacoes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tb_avaliacoes.
     */
    skip?: number
    distinct?: Tb_avaliacoesScalarFieldEnum | Tb_avaliacoesScalarFieldEnum[]
  }


  /**
   * Tb_avaliacoes create
   */
  export type Tb_avaliacoesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * The data needed to create a Tb_avaliacoes.
     */
    data: XOR<Tb_avaliacoesCreateInput, Tb_avaliacoesUncheckedCreateInput>
  }


  /**
   * Tb_avaliacoes createMany
   */
  export type Tb_avaliacoesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tb_avaliacoes.
     */
    data: Tb_avaliacoesCreateManyInput | Tb_avaliacoesCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Tb_avaliacoes update
   */
  export type Tb_avaliacoesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * The data needed to update a Tb_avaliacoes.
     */
    data: XOR<Tb_avaliacoesUpdateInput, Tb_avaliacoesUncheckedUpdateInput>
    /**
     * Choose, which Tb_avaliacoes to update.
     */
    where: Tb_avaliacoesWhereUniqueInput
  }


  /**
   * Tb_avaliacoes updateMany
   */
  export type Tb_avaliacoesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tb_avaliacoes.
     */
    data: XOR<Tb_avaliacoesUpdateManyMutationInput, Tb_avaliacoesUncheckedUpdateManyInput>
    /**
     * Filter which Tb_avaliacoes to update
     */
    where?: Tb_avaliacoesWhereInput
  }


  /**
   * Tb_avaliacoes upsert
   */
  export type Tb_avaliacoesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * The filter to search for the Tb_avaliacoes to update in case it exists.
     */
    where: Tb_avaliacoesWhereUniqueInput
    /**
     * In case the Tb_avaliacoes found by the `where` argument doesn't exist, create a new Tb_avaliacoes with this data.
     */
    create: XOR<Tb_avaliacoesCreateInput, Tb_avaliacoesUncheckedCreateInput>
    /**
     * In case the Tb_avaliacoes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Tb_avaliacoesUpdateInput, Tb_avaliacoesUncheckedUpdateInput>
  }


  /**
   * Tb_avaliacoes delete
   */
  export type Tb_avaliacoesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
    /**
     * Filter which Tb_avaliacoes to delete.
     */
    where: Tb_avaliacoesWhereUniqueInput
  }


  /**
   * Tb_avaliacoes deleteMany
   */
  export type Tb_avaliacoesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tb_avaliacoes to delete
     */
    where?: Tb_avaliacoesWhereInput
  }


  /**
   * Tb_avaliacoes without action
   */
  export type Tb_avaliacoesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tb_avaliacoes
     */
    select?: Tb_avaliacoesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Tb_avaliacoesInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Tb_usuariosScalarFieldEnum: {
    id: 'id',
    email: 'email',
    nome: 'nome',
    senha: 'senha',
    arquivo: 'arquivo'
  };

  export type Tb_usuariosScalarFieldEnum = (typeof Tb_usuariosScalarFieldEnum)[keyof typeof Tb_usuariosScalarFieldEnum]


  export const Tb_categoriaScalarFieldEnum: {
    idCat: 'idCat',
    nomeCat: 'nomeCat'
  };

  export type Tb_categoriaScalarFieldEnum = (typeof Tb_categoriaScalarFieldEnum)[keyof typeof Tb_categoriaScalarFieldEnum]


  export const Tb_perguntasScalarFieldEnum: {
    idPer: 'idPer',
    idCat: 'idCat',
    idUsu: 'idUsu',
    tituloPer: 'tituloPer',
    conteudoPer: 'conteudoPer'
  };

  export type Tb_perguntasScalarFieldEnum = (typeof Tb_perguntasScalarFieldEnum)[keyof typeof Tb_perguntasScalarFieldEnum]


  export const Tb_respostasScalarFieldEnum: {
    idRes: 'idRes',
    idPer: 'idPer',
    idUsu: 'idUsu',
    conteudoRes: 'conteudoRes'
  };

  export type Tb_respostasScalarFieldEnum = (typeof Tb_respostasScalarFieldEnum)[keyof typeof Tb_respostasScalarFieldEnum]


  export const Tb_avaliacoesScalarFieldEnum: {
    idAva: 'idAva',
    idUsuAva: 'idUsuAva',
    tipoAva: 'tipoAva',
    idPost: 'idPost',
    tipoPost: 'tipoPost'
  };

  export type Tb_avaliacoesScalarFieldEnum = (typeof Tb_avaliacoesScalarFieldEnum)[keyof typeof Tb_avaliacoesScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type Tb_usuariosWhereInput = {
    AND?: Tb_usuariosWhereInput | Tb_usuariosWhereInput[]
    OR?: Tb_usuariosWhereInput[]
    NOT?: Tb_usuariosWhereInput | Tb_usuariosWhereInput[]
    id?: IntFilter<"Tb_usuarios"> | number
    email?: StringFilter<"Tb_usuarios"> | string
    nome?: StringFilter<"Tb_usuarios"> | string
    senha?: StringFilter<"Tb_usuarios"> | string
    arquivo?: StringFilter<"Tb_usuarios"> | string
    perguntas?: Tb_perguntasListRelationFilter
    respostas?: Tb_respostasListRelationFilter
    avaliacoes?: Tb_avaliacoesListRelationFilter
  }

  export type Tb_usuariosOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    nome?: SortOrder
    senha?: SortOrder
    arquivo?: SortOrder
    perguntas?: Tb_perguntasOrderByRelationAggregateInput
    respostas?: Tb_respostasOrderByRelationAggregateInput
    avaliacoes?: Tb_avaliacoesOrderByRelationAggregateInput
  }

  export type Tb_usuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: Tb_usuariosWhereInput | Tb_usuariosWhereInput[]
    OR?: Tb_usuariosWhereInput[]
    NOT?: Tb_usuariosWhereInput | Tb_usuariosWhereInput[]
    nome?: StringFilter<"Tb_usuarios"> | string
    senha?: StringFilter<"Tb_usuarios"> | string
    arquivo?: StringFilter<"Tb_usuarios"> | string
    perguntas?: Tb_perguntasListRelationFilter
    respostas?: Tb_respostasListRelationFilter
    avaliacoes?: Tb_avaliacoesListRelationFilter
  }, "id" | "email">

  export type Tb_usuariosOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    nome?: SortOrder
    senha?: SortOrder
    arquivo?: SortOrder
    _count?: Tb_usuariosCountOrderByAggregateInput
    _avg?: Tb_usuariosAvgOrderByAggregateInput
    _max?: Tb_usuariosMaxOrderByAggregateInput
    _min?: Tb_usuariosMinOrderByAggregateInput
    _sum?: Tb_usuariosSumOrderByAggregateInput
  }

  export type Tb_usuariosScalarWhereWithAggregatesInput = {
    AND?: Tb_usuariosScalarWhereWithAggregatesInput | Tb_usuariosScalarWhereWithAggregatesInput[]
    OR?: Tb_usuariosScalarWhereWithAggregatesInput[]
    NOT?: Tb_usuariosScalarWhereWithAggregatesInput | Tb_usuariosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tb_usuarios"> | number
    email?: StringWithAggregatesFilter<"Tb_usuarios"> | string
    nome?: StringWithAggregatesFilter<"Tb_usuarios"> | string
    senha?: StringWithAggregatesFilter<"Tb_usuarios"> | string
    arquivo?: StringWithAggregatesFilter<"Tb_usuarios"> | string
  }

  export type Tb_categoriaWhereInput = {
    AND?: Tb_categoriaWhereInput | Tb_categoriaWhereInput[]
    OR?: Tb_categoriaWhereInput[]
    NOT?: Tb_categoriaWhereInput | Tb_categoriaWhereInput[]
    idCat?: IntFilter<"Tb_categoria"> | number
    nomeCat?: StringFilter<"Tb_categoria"> | string
    pergunta?: Tb_perguntasListRelationFilter
  }

  export type Tb_categoriaOrderByWithRelationInput = {
    idCat?: SortOrder
    nomeCat?: SortOrder
    pergunta?: Tb_perguntasOrderByRelationAggregateInput
  }

  export type Tb_categoriaWhereUniqueInput = Prisma.AtLeast<{
    idCat?: number
    AND?: Tb_categoriaWhereInput | Tb_categoriaWhereInput[]
    OR?: Tb_categoriaWhereInput[]
    NOT?: Tb_categoriaWhereInput | Tb_categoriaWhereInput[]
    nomeCat?: StringFilter<"Tb_categoria"> | string
    pergunta?: Tb_perguntasListRelationFilter
  }, "idCat">

  export type Tb_categoriaOrderByWithAggregationInput = {
    idCat?: SortOrder
    nomeCat?: SortOrder
    _count?: Tb_categoriaCountOrderByAggregateInput
    _avg?: Tb_categoriaAvgOrderByAggregateInput
    _max?: Tb_categoriaMaxOrderByAggregateInput
    _min?: Tb_categoriaMinOrderByAggregateInput
    _sum?: Tb_categoriaSumOrderByAggregateInput
  }

  export type Tb_categoriaScalarWhereWithAggregatesInput = {
    AND?: Tb_categoriaScalarWhereWithAggregatesInput | Tb_categoriaScalarWhereWithAggregatesInput[]
    OR?: Tb_categoriaScalarWhereWithAggregatesInput[]
    NOT?: Tb_categoriaScalarWhereWithAggregatesInput | Tb_categoriaScalarWhereWithAggregatesInput[]
    idCat?: IntWithAggregatesFilter<"Tb_categoria"> | number
    nomeCat?: StringWithAggregatesFilter<"Tb_categoria"> | string
  }

  export type Tb_perguntasWhereInput = {
    AND?: Tb_perguntasWhereInput | Tb_perguntasWhereInput[]
    OR?: Tb_perguntasWhereInput[]
    NOT?: Tb_perguntasWhereInput | Tb_perguntasWhereInput[]
    idPer?: IntFilter<"Tb_perguntas"> | number
    idCat?: IntFilter<"Tb_perguntas"> | number
    idUsu?: IntFilter<"Tb_perguntas"> | number
    tituloPer?: StringFilter<"Tb_perguntas"> | string
    conteudoPer?: StringFilter<"Tb_perguntas"> | string
    categorias?: XOR<Tb_categoriaRelationFilter, Tb_categoriaWhereInput>
    usuarios?: XOR<Tb_usuariosRelationFilter, Tb_usuariosWhereInput>
    respostas?: Tb_respostasListRelationFilter
  }

  export type Tb_perguntasOrderByWithRelationInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
    tituloPer?: SortOrder
    conteudoPer?: SortOrder
    categorias?: Tb_categoriaOrderByWithRelationInput
    usuarios?: Tb_usuariosOrderByWithRelationInput
    respostas?: Tb_respostasOrderByRelationAggregateInput
  }

  export type Tb_perguntasWhereUniqueInput = Prisma.AtLeast<{
    idPer?: number
    AND?: Tb_perguntasWhereInput | Tb_perguntasWhereInput[]
    OR?: Tb_perguntasWhereInput[]
    NOT?: Tb_perguntasWhereInput | Tb_perguntasWhereInput[]
    idCat?: IntFilter<"Tb_perguntas"> | number
    idUsu?: IntFilter<"Tb_perguntas"> | number
    tituloPer?: StringFilter<"Tb_perguntas"> | string
    conteudoPer?: StringFilter<"Tb_perguntas"> | string
    categorias?: XOR<Tb_categoriaRelationFilter, Tb_categoriaWhereInput>
    usuarios?: XOR<Tb_usuariosRelationFilter, Tb_usuariosWhereInput>
    respostas?: Tb_respostasListRelationFilter
  }, "idPer">

  export type Tb_perguntasOrderByWithAggregationInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
    tituloPer?: SortOrder
    conteudoPer?: SortOrder
    _count?: Tb_perguntasCountOrderByAggregateInput
    _avg?: Tb_perguntasAvgOrderByAggregateInput
    _max?: Tb_perguntasMaxOrderByAggregateInput
    _min?: Tb_perguntasMinOrderByAggregateInput
    _sum?: Tb_perguntasSumOrderByAggregateInput
  }

  export type Tb_perguntasScalarWhereWithAggregatesInput = {
    AND?: Tb_perguntasScalarWhereWithAggregatesInput | Tb_perguntasScalarWhereWithAggregatesInput[]
    OR?: Tb_perguntasScalarWhereWithAggregatesInput[]
    NOT?: Tb_perguntasScalarWhereWithAggregatesInput | Tb_perguntasScalarWhereWithAggregatesInput[]
    idPer?: IntWithAggregatesFilter<"Tb_perguntas"> | number
    idCat?: IntWithAggregatesFilter<"Tb_perguntas"> | number
    idUsu?: IntWithAggregatesFilter<"Tb_perguntas"> | number
    tituloPer?: StringWithAggregatesFilter<"Tb_perguntas"> | string
    conteudoPer?: StringWithAggregatesFilter<"Tb_perguntas"> | string
  }

  export type Tb_respostasWhereInput = {
    AND?: Tb_respostasWhereInput | Tb_respostasWhereInput[]
    OR?: Tb_respostasWhereInput[]
    NOT?: Tb_respostasWhereInput | Tb_respostasWhereInput[]
    idRes?: IntFilter<"Tb_respostas"> | number
    idPer?: IntFilter<"Tb_respostas"> | number
    idUsu?: IntFilter<"Tb_respostas"> | number
    conteudoRes?: StringFilter<"Tb_respostas"> | string
    perguntas?: XOR<Tb_perguntasRelationFilter, Tb_perguntasWhereInput>
    usuarios?: XOR<Tb_usuariosRelationFilter, Tb_usuariosWhereInput>
  }

  export type Tb_respostasOrderByWithRelationInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
    conteudoRes?: SortOrder
    perguntas?: Tb_perguntasOrderByWithRelationInput
    usuarios?: Tb_usuariosOrderByWithRelationInput
  }

  export type Tb_respostasWhereUniqueInput = Prisma.AtLeast<{
    idRes?: number
    AND?: Tb_respostasWhereInput | Tb_respostasWhereInput[]
    OR?: Tb_respostasWhereInput[]
    NOT?: Tb_respostasWhereInput | Tb_respostasWhereInput[]
    idPer?: IntFilter<"Tb_respostas"> | number
    idUsu?: IntFilter<"Tb_respostas"> | number
    conteudoRes?: StringFilter<"Tb_respostas"> | string
    perguntas?: XOR<Tb_perguntasRelationFilter, Tb_perguntasWhereInput>
    usuarios?: XOR<Tb_usuariosRelationFilter, Tb_usuariosWhereInput>
  }, "idRes">

  export type Tb_respostasOrderByWithAggregationInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
    conteudoRes?: SortOrder
    _count?: Tb_respostasCountOrderByAggregateInput
    _avg?: Tb_respostasAvgOrderByAggregateInput
    _max?: Tb_respostasMaxOrderByAggregateInput
    _min?: Tb_respostasMinOrderByAggregateInput
    _sum?: Tb_respostasSumOrderByAggregateInput
  }

  export type Tb_respostasScalarWhereWithAggregatesInput = {
    AND?: Tb_respostasScalarWhereWithAggregatesInput | Tb_respostasScalarWhereWithAggregatesInput[]
    OR?: Tb_respostasScalarWhereWithAggregatesInput[]
    NOT?: Tb_respostasScalarWhereWithAggregatesInput | Tb_respostasScalarWhereWithAggregatesInput[]
    idRes?: IntWithAggregatesFilter<"Tb_respostas"> | number
    idPer?: IntWithAggregatesFilter<"Tb_respostas"> | number
    idUsu?: IntWithAggregatesFilter<"Tb_respostas"> | number
    conteudoRes?: StringWithAggregatesFilter<"Tb_respostas"> | string
  }

  export type Tb_avaliacoesWhereInput = {
    AND?: Tb_avaliacoesWhereInput | Tb_avaliacoesWhereInput[]
    OR?: Tb_avaliacoesWhereInput[]
    NOT?: Tb_avaliacoesWhereInput | Tb_avaliacoesWhereInput[]
    idAva?: IntFilter<"Tb_avaliacoes"> | number
    idUsuAva?: IntFilter<"Tb_avaliacoes"> | number
    tipoAva?: StringFilter<"Tb_avaliacoes"> | string
    idPost?: IntFilter<"Tb_avaliacoes"> | number
    tipoPost?: StringFilter<"Tb_avaliacoes"> | string
    usuarios?: XOR<Tb_usuariosRelationFilter, Tb_usuariosWhereInput>
  }

  export type Tb_avaliacoesOrderByWithRelationInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    tipoAva?: SortOrder
    idPost?: SortOrder
    tipoPost?: SortOrder
    usuarios?: Tb_usuariosOrderByWithRelationInput
  }

  export type Tb_avaliacoesWhereUniqueInput = Prisma.AtLeast<{
    idAva?: number
    AND?: Tb_avaliacoesWhereInput | Tb_avaliacoesWhereInput[]
    OR?: Tb_avaliacoesWhereInput[]
    NOT?: Tb_avaliacoesWhereInput | Tb_avaliacoesWhereInput[]
    idUsuAva?: IntFilter<"Tb_avaliacoes"> | number
    tipoAva?: StringFilter<"Tb_avaliacoes"> | string
    idPost?: IntFilter<"Tb_avaliacoes"> | number
    tipoPost?: StringFilter<"Tb_avaliacoes"> | string
    usuarios?: XOR<Tb_usuariosRelationFilter, Tb_usuariosWhereInput>
  }, "idAva">

  export type Tb_avaliacoesOrderByWithAggregationInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    tipoAva?: SortOrder
    idPost?: SortOrder
    tipoPost?: SortOrder
    _count?: Tb_avaliacoesCountOrderByAggregateInput
    _avg?: Tb_avaliacoesAvgOrderByAggregateInput
    _max?: Tb_avaliacoesMaxOrderByAggregateInput
    _min?: Tb_avaliacoesMinOrderByAggregateInput
    _sum?: Tb_avaliacoesSumOrderByAggregateInput
  }

  export type Tb_avaliacoesScalarWhereWithAggregatesInput = {
    AND?: Tb_avaliacoesScalarWhereWithAggregatesInput | Tb_avaliacoesScalarWhereWithAggregatesInput[]
    OR?: Tb_avaliacoesScalarWhereWithAggregatesInput[]
    NOT?: Tb_avaliacoesScalarWhereWithAggregatesInput | Tb_avaliacoesScalarWhereWithAggregatesInput[]
    idAva?: IntWithAggregatesFilter<"Tb_avaliacoes"> | number
    idUsuAva?: IntWithAggregatesFilter<"Tb_avaliacoes"> | number
    tipoAva?: StringWithAggregatesFilter<"Tb_avaliacoes"> | string
    idPost?: IntWithAggregatesFilter<"Tb_avaliacoes"> | number
    tipoPost?: StringWithAggregatesFilter<"Tb_avaliacoes"> | string
  }

  export type Tb_usuariosCreateInput = {
    email: string
    nome: string
    senha: string
    arquivo: string
    perguntas?: Tb_perguntasCreateNestedManyWithoutUsuariosInput
    respostas?: Tb_respostasCreateNestedManyWithoutUsuariosInput
    avaliacoes?: Tb_avaliacoesCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosUncheckedCreateInput = {
    id?: number
    email: string
    nome: string
    senha: string
    arquivo: string
    perguntas?: Tb_perguntasUncheckedCreateNestedManyWithoutUsuariosInput
    respostas?: Tb_respostasUncheckedCreateNestedManyWithoutUsuariosInput
    avaliacoes?: Tb_avaliacoesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUpdateManyWithoutUsuariosNestedInput
    respostas?: Tb_respostasUpdateManyWithoutUsuariosNestedInput
    avaliacoes?: Tb_avaliacoesUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_usuariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUncheckedUpdateManyWithoutUsuariosNestedInput
    respostas?: Tb_respostasUncheckedUpdateManyWithoutUsuariosNestedInput
    avaliacoes?: Tb_avaliacoesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_usuariosCreateManyInput = {
    id?: number
    email: string
    nome: string
    senha: string
    arquivo: string
  }

  export type Tb_usuariosUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_usuariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_categoriaCreateInput = {
    nomeCat: string
    pergunta?: Tb_perguntasCreateNestedManyWithoutCategoriasInput
  }

  export type Tb_categoriaUncheckedCreateInput = {
    idCat?: number
    nomeCat: string
    pergunta?: Tb_perguntasUncheckedCreateNestedManyWithoutCategoriasInput
  }

  export type Tb_categoriaUpdateInput = {
    nomeCat?: StringFieldUpdateOperationsInput | string
    pergunta?: Tb_perguntasUpdateManyWithoutCategoriasNestedInput
  }

  export type Tb_categoriaUncheckedUpdateInput = {
    idCat?: IntFieldUpdateOperationsInput | number
    nomeCat?: StringFieldUpdateOperationsInput | string
    pergunta?: Tb_perguntasUncheckedUpdateManyWithoutCategoriasNestedInput
  }

  export type Tb_categoriaCreateManyInput = {
    idCat?: number
    nomeCat: string
  }

  export type Tb_categoriaUpdateManyMutationInput = {
    nomeCat?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_categoriaUncheckedUpdateManyInput = {
    idCat?: IntFieldUpdateOperationsInput | number
    nomeCat?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_perguntasCreateInput = {
    tituloPer: string
    conteudoPer: string
    categorias: Tb_categoriaCreateNestedOneWithoutPerguntaInput
    usuarios: Tb_usuariosCreateNestedOneWithoutPerguntasInput
    respostas?: Tb_respostasCreateNestedManyWithoutPerguntasInput
  }

  export type Tb_perguntasUncheckedCreateInput = {
    idPer?: number
    idCat: number
    idUsu: number
    tituloPer: string
    conteudoPer: string
    respostas?: Tb_respostasUncheckedCreateNestedManyWithoutPerguntasInput
  }

  export type Tb_perguntasUpdateInput = {
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    categorias?: Tb_categoriaUpdateOneRequiredWithoutPerguntaNestedInput
    usuarios?: Tb_usuariosUpdateOneRequiredWithoutPerguntasNestedInput
    respostas?: Tb_respostasUpdateManyWithoutPerguntasNestedInput
  }

  export type Tb_perguntasUncheckedUpdateInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idCat?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    respostas?: Tb_respostasUncheckedUpdateManyWithoutPerguntasNestedInput
  }

  export type Tb_perguntasCreateManyInput = {
    idPer?: number
    idCat: number
    idUsu: number
    tituloPer: string
    conteudoPer: string
  }

  export type Tb_perguntasUpdateManyMutationInput = {
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_perguntasUncheckedUpdateManyInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idCat?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasCreateInput = {
    conteudoRes: string
    perguntas: Tb_perguntasCreateNestedOneWithoutRespostasInput
    usuarios: Tb_usuariosCreateNestedOneWithoutRespostasInput
  }

  export type Tb_respostasUncheckedCreateInput = {
    idRes?: number
    idPer: number
    idUsu: number
    conteudoRes: string
  }

  export type Tb_respostasUpdateInput = {
    conteudoRes?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUpdateOneRequiredWithoutRespostasNestedInput
    usuarios?: Tb_usuariosUpdateOneRequiredWithoutRespostasNestedInput
  }

  export type Tb_respostasUncheckedUpdateInput = {
    idRes?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasCreateManyInput = {
    idRes?: number
    idPer: number
    idUsu: number
    conteudoRes: string
  }

  export type Tb_respostasUpdateManyMutationInput = {
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasUncheckedUpdateManyInput = {
    idRes?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_avaliacoesCreateInput = {
    tipoAva: string
    idPost: number
    tipoPost: string
    usuarios: Tb_usuariosCreateNestedOneWithoutAvaliacoesInput
  }

  export type Tb_avaliacoesUncheckedCreateInput = {
    idAva?: number
    idUsuAva: number
    tipoAva: string
    idPost: number
    tipoPost: string
  }

  export type Tb_avaliacoesUpdateInput = {
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
    usuarios?: Tb_usuariosUpdateOneRequiredWithoutAvaliacoesNestedInput
  }

  export type Tb_avaliacoesUncheckedUpdateInput = {
    idAva?: IntFieldUpdateOperationsInput | number
    idUsuAva?: IntFieldUpdateOperationsInput | number
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_avaliacoesCreateManyInput = {
    idAva?: number
    idUsuAva: number
    tipoAva: string
    idPost: number
    tipoPost: string
  }

  export type Tb_avaliacoesUpdateManyMutationInput = {
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_avaliacoesUncheckedUpdateManyInput = {
    idAva?: IntFieldUpdateOperationsInput | number
    idUsuAva?: IntFieldUpdateOperationsInput | number
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Tb_perguntasListRelationFilter = {
    every?: Tb_perguntasWhereInput
    some?: Tb_perguntasWhereInput
    none?: Tb_perguntasWhereInput
  }

  export type Tb_respostasListRelationFilter = {
    every?: Tb_respostasWhereInput
    some?: Tb_respostasWhereInput
    none?: Tb_respostasWhereInput
  }

  export type Tb_avaliacoesListRelationFilter = {
    every?: Tb_avaliacoesWhereInput
    some?: Tb_avaliacoesWhereInput
    none?: Tb_avaliacoesWhereInput
  }

  export type Tb_perguntasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tb_respostasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tb_avaliacoesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Tb_usuariosCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nome?: SortOrder
    senha?: SortOrder
    arquivo?: SortOrder
  }

  export type Tb_usuariosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Tb_usuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nome?: SortOrder
    senha?: SortOrder
    arquivo?: SortOrder
  }

  export type Tb_usuariosMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    nome?: SortOrder
    senha?: SortOrder
    arquivo?: SortOrder
  }

  export type Tb_usuariosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Tb_categoriaCountOrderByAggregateInput = {
    idCat?: SortOrder
    nomeCat?: SortOrder
  }

  export type Tb_categoriaAvgOrderByAggregateInput = {
    idCat?: SortOrder
  }

  export type Tb_categoriaMaxOrderByAggregateInput = {
    idCat?: SortOrder
    nomeCat?: SortOrder
  }

  export type Tb_categoriaMinOrderByAggregateInput = {
    idCat?: SortOrder
    nomeCat?: SortOrder
  }

  export type Tb_categoriaSumOrderByAggregateInput = {
    idCat?: SortOrder
  }

  export type Tb_categoriaRelationFilter = {
    is?: Tb_categoriaWhereInput
    isNot?: Tb_categoriaWhereInput
  }

  export type Tb_usuariosRelationFilter = {
    is?: Tb_usuariosWhereInput
    isNot?: Tb_usuariosWhereInput
  }

  export type Tb_perguntasCountOrderByAggregateInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
    tituloPer?: SortOrder
    conteudoPer?: SortOrder
  }

  export type Tb_perguntasAvgOrderByAggregateInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
  }

  export type Tb_perguntasMaxOrderByAggregateInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
    tituloPer?: SortOrder
    conteudoPer?: SortOrder
  }

  export type Tb_perguntasMinOrderByAggregateInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
    tituloPer?: SortOrder
    conteudoPer?: SortOrder
  }

  export type Tb_perguntasSumOrderByAggregateInput = {
    idPer?: SortOrder
    idCat?: SortOrder
    idUsu?: SortOrder
  }

  export type Tb_perguntasRelationFilter = {
    is?: Tb_perguntasWhereInput
    isNot?: Tb_perguntasWhereInput
  }

  export type Tb_respostasCountOrderByAggregateInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
    conteudoRes?: SortOrder
  }

  export type Tb_respostasAvgOrderByAggregateInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
  }

  export type Tb_respostasMaxOrderByAggregateInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
    conteudoRes?: SortOrder
  }

  export type Tb_respostasMinOrderByAggregateInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
    conteudoRes?: SortOrder
  }

  export type Tb_respostasSumOrderByAggregateInput = {
    idRes?: SortOrder
    idPer?: SortOrder
    idUsu?: SortOrder
  }

  export type Tb_avaliacoesCountOrderByAggregateInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    tipoAva?: SortOrder
    idPost?: SortOrder
    tipoPost?: SortOrder
  }

  export type Tb_avaliacoesAvgOrderByAggregateInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    idPost?: SortOrder
  }

  export type Tb_avaliacoesMaxOrderByAggregateInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    tipoAva?: SortOrder
    idPost?: SortOrder
    tipoPost?: SortOrder
  }

  export type Tb_avaliacoesMinOrderByAggregateInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    tipoAva?: SortOrder
    idPost?: SortOrder
    tipoPost?: SortOrder
  }

  export type Tb_avaliacoesSumOrderByAggregateInput = {
    idAva?: SortOrder
    idUsuAva?: SortOrder
    idPost?: SortOrder
  }

  export type Tb_perguntasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<Tb_perguntasCreateWithoutUsuariosInput, Tb_perguntasUncheckedCreateWithoutUsuariosInput> | Tb_perguntasCreateWithoutUsuariosInput[] | Tb_perguntasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutUsuariosInput | Tb_perguntasCreateOrConnectWithoutUsuariosInput[]
    createMany?: Tb_perguntasCreateManyUsuariosInputEnvelope
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
  }

  export type Tb_respostasCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<Tb_respostasCreateWithoutUsuariosInput, Tb_respostasUncheckedCreateWithoutUsuariosInput> | Tb_respostasCreateWithoutUsuariosInput[] | Tb_respostasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutUsuariosInput | Tb_respostasCreateOrConnectWithoutUsuariosInput[]
    createMany?: Tb_respostasCreateManyUsuariosInputEnvelope
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
  }

  export type Tb_avaliacoesCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<Tb_avaliacoesCreateWithoutUsuariosInput, Tb_avaliacoesUncheckedCreateWithoutUsuariosInput> | Tb_avaliacoesCreateWithoutUsuariosInput[] | Tb_avaliacoesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_avaliacoesCreateOrConnectWithoutUsuariosInput | Tb_avaliacoesCreateOrConnectWithoutUsuariosInput[]
    createMany?: Tb_avaliacoesCreateManyUsuariosInputEnvelope
    connect?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
  }

  export type Tb_perguntasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<Tb_perguntasCreateWithoutUsuariosInput, Tb_perguntasUncheckedCreateWithoutUsuariosInput> | Tb_perguntasCreateWithoutUsuariosInput[] | Tb_perguntasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutUsuariosInput | Tb_perguntasCreateOrConnectWithoutUsuariosInput[]
    createMany?: Tb_perguntasCreateManyUsuariosInputEnvelope
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
  }

  export type Tb_respostasUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<Tb_respostasCreateWithoutUsuariosInput, Tb_respostasUncheckedCreateWithoutUsuariosInput> | Tb_respostasCreateWithoutUsuariosInput[] | Tb_respostasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutUsuariosInput | Tb_respostasCreateOrConnectWithoutUsuariosInput[]
    createMany?: Tb_respostasCreateManyUsuariosInputEnvelope
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
  }

  export type Tb_avaliacoesUncheckedCreateNestedManyWithoutUsuariosInput = {
    create?: XOR<Tb_avaliacoesCreateWithoutUsuariosInput, Tb_avaliacoesUncheckedCreateWithoutUsuariosInput> | Tb_avaliacoesCreateWithoutUsuariosInput[] | Tb_avaliacoesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_avaliacoesCreateOrConnectWithoutUsuariosInput | Tb_avaliacoesCreateOrConnectWithoutUsuariosInput[]
    createMany?: Tb_avaliacoesCreateManyUsuariosInputEnvelope
    connect?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type Tb_perguntasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<Tb_perguntasCreateWithoutUsuariosInput, Tb_perguntasUncheckedCreateWithoutUsuariosInput> | Tb_perguntasCreateWithoutUsuariosInput[] | Tb_perguntasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutUsuariosInput | Tb_perguntasCreateOrConnectWithoutUsuariosInput[]
    upsert?: Tb_perguntasUpsertWithWhereUniqueWithoutUsuariosInput | Tb_perguntasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: Tb_perguntasCreateManyUsuariosInputEnvelope
    set?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    disconnect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    delete?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    update?: Tb_perguntasUpdateWithWhereUniqueWithoutUsuariosInput | Tb_perguntasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: Tb_perguntasUpdateManyWithWhereWithoutUsuariosInput | Tb_perguntasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: Tb_perguntasScalarWhereInput | Tb_perguntasScalarWhereInput[]
  }

  export type Tb_respostasUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<Tb_respostasCreateWithoutUsuariosInput, Tb_respostasUncheckedCreateWithoutUsuariosInput> | Tb_respostasCreateWithoutUsuariosInput[] | Tb_respostasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutUsuariosInput | Tb_respostasCreateOrConnectWithoutUsuariosInput[]
    upsert?: Tb_respostasUpsertWithWhereUniqueWithoutUsuariosInput | Tb_respostasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: Tb_respostasCreateManyUsuariosInputEnvelope
    set?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    disconnect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    delete?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    update?: Tb_respostasUpdateWithWhereUniqueWithoutUsuariosInput | Tb_respostasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: Tb_respostasUpdateManyWithWhereWithoutUsuariosInput | Tb_respostasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: Tb_respostasScalarWhereInput | Tb_respostasScalarWhereInput[]
  }

  export type Tb_avaliacoesUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<Tb_avaliacoesCreateWithoutUsuariosInput, Tb_avaliacoesUncheckedCreateWithoutUsuariosInput> | Tb_avaliacoesCreateWithoutUsuariosInput[] | Tb_avaliacoesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_avaliacoesCreateOrConnectWithoutUsuariosInput | Tb_avaliacoesCreateOrConnectWithoutUsuariosInput[]
    upsert?: Tb_avaliacoesUpsertWithWhereUniqueWithoutUsuariosInput | Tb_avaliacoesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: Tb_avaliacoesCreateManyUsuariosInputEnvelope
    set?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    disconnect?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    delete?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    connect?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    update?: Tb_avaliacoesUpdateWithWhereUniqueWithoutUsuariosInput | Tb_avaliacoesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: Tb_avaliacoesUpdateManyWithWhereWithoutUsuariosInput | Tb_avaliacoesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: Tb_avaliacoesScalarWhereInput | Tb_avaliacoesScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type Tb_perguntasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<Tb_perguntasCreateWithoutUsuariosInput, Tb_perguntasUncheckedCreateWithoutUsuariosInput> | Tb_perguntasCreateWithoutUsuariosInput[] | Tb_perguntasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutUsuariosInput | Tb_perguntasCreateOrConnectWithoutUsuariosInput[]
    upsert?: Tb_perguntasUpsertWithWhereUniqueWithoutUsuariosInput | Tb_perguntasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: Tb_perguntasCreateManyUsuariosInputEnvelope
    set?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    disconnect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    delete?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    update?: Tb_perguntasUpdateWithWhereUniqueWithoutUsuariosInput | Tb_perguntasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: Tb_perguntasUpdateManyWithWhereWithoutUsuariosInput | Tb_perguntasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: Tb_perguntasScalarWhereInput | Tb_perguntasScalarWhereInput[]
  }

  export type Tb_respostasUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<Tb_respostasCreateWithoutUsuariosInput, Tb_respostasUncheckedCreateWithoutUsuariosInput> | Tb_respostasCreateWithoutUsuariosInput[] | Tb_respostasUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutUsuariosInput | Tb_respostasCreateOrConnectWithoutUsuariosInput[]
    upsert?: Tb_respostasUpsertWithWhereUniqueWithoutUsuariosInput | Tb_respostasUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: Tb_respostasCreateManyUsuariosInputEnvelope
    set?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    disconnect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    delete?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    update?: Tb_respostasUpdateWithWhereUniqueWithoutUsuariosInput | Tb_respostasUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: Tb_respostasUpdateManyWithWhereWithoutUsuariosInput | Tb_respostasUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: Tb_respostasScalarWhereInput | Tb_respostasScalarWhereInput[]
  }

  export type Tb_avaliacoesUncheckedUpdateManyWithoutUsuariosNestedInput = {
    create?: XOR<Tb_avaliacoesCreateWithoutUsuariosInput, Tb_avaliacoesUncheckedCreateWithoutUsuariosInput> | Tb_avaliacoesCreateWithoutUsuariosInput[] | Tb_avaliacoesUncheckedCreateWithoutUsuariosInput[]
    connectOrCreate?: Tb_avaliacoesCreateOrConnectWithoutUsuariosInput | Tb_avaliacoesCreateOrConnectWithoutUsuariosInput[]
    upsert?: Tb_avaliacoesUpsertWithWhereUniqueWithoutUsuariosInput | Tb_avaliacoesUpsertWithWhereUniqueWithoutUsuariosInput[]
    createMany?: Tb_avaliacoesCreateManyUsuariosInputEnvelope
    set?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    disconnect?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    delete?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    connect?: Tb_avaliacoesWhereUniqueInput | Tb_avaliacoesWhereUniqueInput[]
    update?: Tb_avaliacoesUpdateWithWhereUniqueWithoutUsuariosInput | Tb_avaliacoesUpdateWithWhereUniqueWithoutUsuariosInput[]
    updateMany?: Tb_avaliacoesUpdateManyWithWhereWithoutUsuariosInput | Tb_avaliacoesUpdateManyWithWhereWithoutUsuariosInput[]
    deleteMany?: Tb_avaliacoesScalarWhereInput | Tb_avaliacoesScalarWhereInput[]
  }

  export type Tb_perguntasCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Tb_perguntasCreateWithoutCategoriasInput, Tb_perguntasUncheckedCreateWithoutCategoriasInput> | Tb_perguntasCreateWithoutCategoriasInput[] | Tb_perguntasUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutCategoriasInput | Tb_perguntasCreateOrConnectWithoutCategoriasInput[]
    createMany?: Tb_perguntasCreateManyCategoriasInputEnvelope
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
  }

  export type Tb_perguntasUncheckedCreateNestedManyWithoutCategoriasInput = {
    create?: XOR<Tb_perguntasCreateWithoutCategoriasInput, Tb_perguntasUncheckedCreateWithoutCategoriasInput> | Tb_perguntasCreateWithoutCategoriasInput[] | Tb_perguntasUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutCategoriasInput | Tb_perguntasCreateOrConnectWithoutCategoriasInput[]
    createMany?: Tb_perguntasCreateManyCategoriasInputEnvelope
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
  }

  export type Tb_perguntasUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<Tb_perguntasCreateWithoutCategoriasInput, Tb_perguntasUncheckedCreateWithoutCategoriasInput> | Tb_perguntasCreateWithoutCategoriasInput[] | Tb_perguntasUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutCategoriasInput | Tb_perguntasCreateOrConnectWithoutCategoriasInput[]
    upsert?: Tb_perguntasUpsertWithWhereUniqueWithoutCategoriasInput | Tb_perguntasUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: Tb_perguntasCreateManyCategoriasInputEnvelope
    set?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    disconnect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    delete?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    update?: Tb_perguntasUpdateWithWhereUniqueWithoutCategoriasInput | Tb_perguntasUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: Tb_perguntasUpdateManyWithWhereWithoutCategoriasInput | Tb_perguntasUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: Tb_perguntasScalarWhereInput | Tb_perguntasScalarWhereInput[]
  }

  export type Tb_perguntasUncheckedUpdateManyWithoutCategoriasNestedInput = {
    create?: XOR<Tb_perguntasCreateWithoutCategoriasInput, Tb_perguntasUncheckedCreateWithoutCategoriasInput> | Tb_perguntasCreateWithoutCategoriasInput[] | Tb_perguntasUncheckedCreateWithoutCategoriasInput[]
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutCategoriasInput | Tb_perguntasCreateOrConnectWithoutCategoriasInput[]
    upsert?: Tb_perguntasUpsertWithWhereUniqueWithoutCategoriasInput | Tb_perguntasUpsertWithWhereUniqueWithoutCategoriasInput[]
    createMany?: Tb_perguntasCreateManyCategoriasInputEnvelope
    set?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    disconnect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    delete?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    connect?: Tb_perguntasWhereUniqueInput | Tb_perguntasWhereUniqueInput[]
    update?: Tb_perguntasUpdateWithWhereUniqueWithoutCategoriasInput | Tb_perguntasUpdateWithWhereUniqueWithoutCategoriasInput[]
    updateMany?: Tb_perguntasUpdateManyWithWhereWithoutCategoriasInput | Tb_perguntasUpdateManyWithWhereWithoutCategoriasInput[]
    deleteMany?: Tb_perguntasScalarWhereInput | Tb_perguntasScalarWhereInput[]
  }

  export type Tb_categoriaCreateNestedOneWithoutPerguntaInput = {
    create?: XOR<Tb_categoriaCreateWithoutPerguntaInput, Tb_categoriaUncheckedCreateWithoutPerguntaInput>
    connectOrCreate?: Tb_categoriaCreateOrConnectWithoutPerguntaInput
    connect?: Tb_categoriaWhereUniqueInput
  }

  export type Tb_usuariosCreateNestedOneWithoutPerguntasInput = {
    create?: XOR<Tb_usuariosCreateWithoutPerguntasInput, Tb_usuariosUncheckedCreateWithoutPerguntasInput>
    connectOrCreate?: Tb_usuariosCreateOrConnectWithoutPerguntasInput
    connect?: Tb_usuariosWhereUniqueInput
  }

  export type Tb_respostasCreateNestedManyWithoutPerguntasInput = {
    create?: XOR<Tb_respostasCreateWithoutPerguntasInput, Tb_respostasUncheckedCreateWithoutPerguntasInput> | Tb_respostasCreateWithoutPerguntasInput[] | Tb_respostasUncheckedCreateWithoutPerguntasInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutPerguntasInput | Tb_respostasCreateOrConnectWithoutPerguntasInput[]
    createMany?: Tb_respostasCreateManyPerguntasInputEnvelope
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
  }

  export type Tb_respostasUncheckedCreateNestedManyWithoutPerguntasInput = {
    create?: XOR<Tb_respostasCreateWithoutPerguntasInput, Tb_respostasUncheckedCreateWithoutPerguntasInput> | Tb_respostasCreateWithoutPerguntasInput[] | Tb_respostasUncheckedCreateWithoutPerguntasInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutPerguntasInput | Tb_respostasCreateOrConnectWithoutPerguntasInput[]
    createMany?: Tb_respostasCreateManyPerguntasInputEnvelope
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
  }

  export type Tb_categoriaUpdateOneRequiredWithoutPerguntaNestedInput = {
    create?: XOR<Tb_categoriaCreateWithoutPerguntaInput, Tb_categoriaUncheckedCreateWithoutPerguntaInput>
    connectOrCreate?: Tb_categoriaCreateOrConnectWithoutPerguntaInput
    upsert?: Tb_categoriaUpsertWithoutPerguntaInput
    connect?: Tb_categoriaWhereUniqueInput
    update?: XOR<XOR<Tb_categoriaUpdateToOneWithWhereWithoutPerguntaInput, Tb_categoriaUpdateWithoutPerguntaInput>, Tb_categoriaUncheckedUpdateWithoutPerguntaInput>
  }

  export type Tb_usuariosUpdateOneRequiredWithoutPerguntasNestedInput = {
    create?: XOR<Tb_usuariosCreateWithoutPerguntasInput, Tb_usuariosUncheckedCreateWithoutPerguntasInput>
    connectOrCreate?: Tb_usuariosCreateOrConnectWithoutPerguntasInput
    upsert?: Tb_usuariosUpsertWithoutPerguntasInput
    connect?: Tb_usuariosWhereUniqueInput
    update?: XOR<XOR<Tb_usuariosUpdateToOneWithWhereWithoutPerguntasInput, Tb_usuariosUpdateWithoutPerguntasInput>, Tb_usuariosUncheckedUpdateWithoutPerguntasInput>
  }

  export type Tb_respostasUpdateManyWithoutPerguntasNestedInput = {
    create?: XOR<Tb_respostasCreateWithoutPerguntasInput, Tb_respostasUncheckedCreateWithoutPerguntasInput> | Tb_respostasCreateWithoutPerguntasInput[] | Tb_respostasUncheckedCreateWithoutPerguntasInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutPerguntasInput | Tb_respostasCreateOrConnectWithoutPerguntasInput[]
    upsert?: Tb_respostasUpsertWithWhereUniqueWithoutPerguntasInput | Tb_respostasUpsertWithWhereUniqueWithoutPerguntasInput[]
    createMany?: Tb_respostasCreateManyPerguntasInputEnvelope
    set?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    disconnect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    delete?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    update?: Tb_respostasUpdateWithWhereUniqueWithoutPerguntasInput | Tb_respostasUpdateWithWhereUniqueWithoutPerguntasInput[]
    updateMany?: Tb_respostasUpdateManyWithWhereWithoutPerguntasInput | Tb_respostasUpdateManyWithWhereWithoutPerguntasInput[]
    deleteMany?: Tb_respostasScalarWhereInput | Tb_respostasScalarWhereInput[]
  }

  export type Tb_respostasUncheckedUpdateManyWithoutPerguntasNestedInput = {
    create?: XOR<Tb_respostasCreateWithoutPerguntasInput, Tb_respostasUncheckedCreateWithoutPerguntasInput> | Tb_respostasCreateWithoutPerguntasInput[] | Tb_respostasUncheckedCreateWithoutPerguntasInput[]
    connectOrCreate?: Tb_respostasCreateOrConnectWithoutPerguntasInput | Tb_respostasCreateOrConnectWithoutPerguntasInput[]
    upsert?: Tb_respostasUpsertWithWhereUniqueWithoutPerguntasInput | Tb_respostasUpsertWithWhereUniqueWithoutPerguntasInput[]
    createMany?: Tb_respostasCreateManyPerguntasInputEnvelope
    set?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    disconnect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    delete?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    connect?: Tb_respostasWhereUniqueInput | Tb_respostasWhereUniqueInput[]
    update?: Tb_respostasUpdateWithWhereUniqueWithoutPerguntasInput | Tb_respostasUpdateWithWhereUniqueWithoutPerguntasInput[]
    updateMany?: Tb_respostasUpdateManyWithWhereWithoutPerguntasInput | Tb_respostasUpdateManyWithWhereWithoutPerguntasInput[]
    deleteMany?: Tb_respostasScalarWhereInput | Tb_respostasScalarWhereInput[]
  }

  export type Tb_perguntasCreateNestedOneWithoutRespostasInput = {
    create?: XOR<Tb_perguntasCreateWithoutRespostasInput, Tb_perguntasUncheckedCreateWithoutRespostasInput>
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutRespostasInput
    connect?: Tb_perguntasWhereUniqueInput
  }

  export type Tb_usuariosCreateNestedOneWithoutRespostasInput = {
    create?: XOR<Tb_usuariosCreateWithoutRespostasInput, Tb_usuariosUncheckedCreateWithoutRespostasInput>
    connectOrCreate?: Tb_usuariosCreateOrConnectWithoutRespostasInput
    connect?: Tb_usuariosWhereUniqueInput
  }

  export type Tb_perguntasUpdateOneRequiredWithoutRespostasNestedInput = {
    create?: XOR<Tb_perguntasCreateWithoutRespostasInput, Tb_perguntasUncheckedCreateWithoutRespostasInput>
    connectOrCreate?: Tb_perguntasCreateOrConnectWithoutRespostasInput
    upsert?: Tb_perguntasUpsertWithoutRespostasInput
    connect?: Tb_perguntasWhereUniqueInput
    update?: XOR<XOR<Tb_perguntasUpdateToOneWithWhereWithoutRespostasInput, Tb_perguntasUpdateWithoutRespostasInput>, Tb_perguntasUncheckedUpdateWithoutRespostasInput>
  }

  export type Tb_usuariosUpdateOneRequiredWithoutRespostasNestedInput = {
    create?: XOR<Tb_usuariosCreateWithoutRespostasInput, Tb_usuariosUncheckedCreateWithoutRespostasInput>
    connectOrCreate?: Tb_usuariosCreateOrConnectWithoutRespostasInput
    upsert?: Tb_usuariosUpsertWithoutRespostasInput
    connect?: Tb_usuariosWhereUniqueInput
    update?: XOR<XOR<Tb_usuariosUpdateToOneWithWhereWithoutRespostasInput, Tb_usuariosUpdateWithoutRespostasInput>, Tb_usuariosUncheckedUpdateWithoutRespostasInput>
  }

  export type Tb_usuariosCreateNestedOneWithoutAvaliacoesInput = {
    create?: XOR<Tb_usuariosCreateWithoutAvaliacoesInput, Tb_usuariosUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: Tb_usuariosCreateOrConnectWithoutAvaliacoesInput
    connect?: Tb_usuariosWhereUniqueInput
  }

  export type Tb_usuariosUpdateOneRequiredWithoutAvaliacoesNestedInput = {
    create?: XOR<Tb_usuariosCreateWithoutAvaliacoesInput, Tb_usuariosUncheckedCreateWithoutAvaliacoesInput>
    connectOrCreate?: Tb_usuariosCreateOrConnectWithoutAvaliacoesInput
    upsert?: Tb_usuariosUpsertWithoutAvaliacoesInput
    connect?: Tb_usuariosWhereUniqueInput
    update?: XOR<XOR<Tb_usuariosUpdateToOneWithWhereWithoutAvaliacoesInput, Tb_usuariosUpdateWithoutAvaliacoesInput>, Tb_usuariosUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Tb_perguntasCreateWithoutUsuariosInput = {
    tituloPer: string
    conteudoPer: string
    categorias: Tb_categoriaCreateNestedOneWithoutPerguntaInput
    respostas?: Tb_respostasCreateNestedManyWithoutPerguntasInput
  }

  export type Tb_perguntasUncheckedCreateWithoutUsuariosInput = {
    idPer?: number
    idCat: number
    tituloPer: string
    conteudoPer: string
    respostas?: Tb_respostasUncheckedCreateNestedManyWithoutPerguntasInput
  }

  export type Tb_perguntasCreateOrConnectWithoutUsuariosInput = {
    where: Tb_perguntasWhereUniqueInput
    create: XOR<Tb_perguntasCreateWithoutUsuariosInput, Tb_perguntasUncheckedCreateWithoutUsuariosInput>
  }

  export type Tb_perguntasCreateManyUsuariosInputEnvelope = {
    data: Tb_perguntasCreateManyUsuariosInput | Tb_perguntasCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type Tb_respostasCreateWithoutUsuariosInput = {
    conteudoRes: string
    perguntas: Tb_perguntasCreateNestedOneWithoutRespostasInput
  }

  export type Tb_respostasUncheckedCreateWithoutUsuariosInput = {
    idRes?: number
    idPer: number
    conteudoRes: string
  }

  export type Tb_respostasCreateOrConnectWithoutUsuariosInput = {
    where: Tb_respostasWhereUniqueInput
    create: XOR<Tb_respostasCreateWithoutUsuariosInput, Tb_respostasUncheckedCreateWithoutUsuariosInput>
  }

  export type Tb_respostasCreateManyUsuariosInputEnvelope = {
    data: Tb_respostasCreateManyUsuariosInput | Tb_respostasCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type Tb_avaliacoesCreateWithoutUsuariosInput = {
    tipoAva: string
    idPost: number
    tipoPost: string
  }

  export type Tb_avaliacoesUncheckedCreateWithoutUsuariosInput = {
    idAva?: number
    tipoAva: string
    idPost: number
    tipoPost: string
  }

  export type Tb_avaliacoesCreateOrConnectWithoutUsuariosInput = {
    where: Tb_avaliacoesWhereUniqueInput
    create: XOR<Tb_avaliacoesCreateWithoutUsuariosInput, Tb_avaliacoesUncheckedCreateWithoutUsuariosInput>
  }

  export type Tb_avaliacoesCreateManyUsuariosInputEnvelope = {
    data: Tb_avaliacoesCreateManyUsuariosInput | Tb_avaliacoesCreateManyUsuariosInput[]
    skipDuplicates?: boolean
  }

  export type Tb_perguntasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: Tb_perguntasWhereUniqueInput
    update: XOR<Tb_perguntasUpdateWithoutUsuariosInput, Tb_perguntasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<Tb_perguntasCreateWithoutUsuariosInput, Tb_perguntasUncheckedCreateWithoutUsuariosInput>
  }

  export type Tb_perguntasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: Tb_perguntasWhereUniqueInput
    data: XOR<Tb_perguntasUpdateWithoutUsuariosInput, Tb_perguntasUncheckedUpdateWithoutUsuariosInput>
  }

  export type Tb_perguntasUpdateManyWithWhereWithoutUsuariosInput = {
    where: Tb_perguntasScalarWhereInput
    data: XOR<Tb_perguntasUpdateManyMutationInput, Tb_perguntasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type Tb_perguntasScalarWhereInput = {
    AND?: Tb_perguntasScalarWhereInput | Tb_perguntasScalarWhereInput[]
    OR?: Tb_perguntasScalarWhereInput[]
    NOT?: Tb_perguntasScalarWhereInput | Tb_perguntasScalarWhereInput[]
    idPer?: IntFilter<"Tb_perguntas"> | number
    idCat?: IntFilter<"Tb_perguntas"> | number
    idUsu?: IntFilter<"Tb_perguntas"> | number
    tituloPer?: StringFilter<"Tb_perguntas"> | string
    conteudoPer?: StringFilter<"Tb_perguntas"> | string
  }

  export type Tb_respostasUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: Tb_respostasWhereUniqueInput
    update: XOR<Tb_respostasUpdateWithoutUsuariosInput, Tb_respostasUncheckedUpdateWithoutUsuariosInput>
    create: XOR<Tb_respostasCreateWithoutUsuariosInput, Tb_respostasUncheckedCreateWithoutUsuariosInput>
  }

  export type Tb_respostasUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: Tb_respostasWhereUniqueInput
    data: XOR<Tb_respostasUpdateWithoutUsuariosInput, Tb_respostasUncheckedUpdateWithoutUsuariosInput>
  }

  export type Tb_respostasUpdateManyWithWhereWithoutUsuariosInput = {
    where: Tb_respostasScalarWhereInput
    data: XOR<Tb_respostasUpdateManyMutationInput, Tb_respostasUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type Tb_respostasScalarWhereInput = {
    AND?: Tb_respostasScalarWhereInput | Tb_respostasScalarWhereInput[]
    OR?: Tb_respostasScalarWhereInput[]
    NOT?: Tb_respostasScalarWhereInput | Tb_respostasScalarWhereInput[]
    idRes?: IntFilter<"Tb_respostas"> | number
    idPer?: IntFilter<"Tb_respostas"> | number
    idUsu?: IntFilter<"Tb_respostas"> | number
    conteudoRes?: StringFilter<"Tb_respostas"> | string
  }

  export type Tb_avaliacoesUpsertWithWhereUniqueWithoutUsuariosInput = {
    where: Tb_avaliacoesWhereUniqueInput
    update: XOR<Tb_avaliacoesUpdateWithoutUsuariosInput, Tb_avaliacoesUncheckedUpdateWithoutUsuariosInput>
    create: XOR<Tb_avaliacoesCreateWithoutUsuariosInput, Tb_avaliacoesUncheckedCreateWithoutUsuariosInput>
  }

  export type Tb_avaliacoesUpdateWithWhereUniqueWithoutUsuariosInput = {
    where: Tb_avaliacoesWhereUniqueInput
    data: XOR<Tb_avaliacoesUpdateWithoutUsuariosInput, Tb_avaliacoesUncheckedUpdateWithoutUsuariosInput>
  }

  export type Tb_avaliacoesUpdateManyWithWhereWithoutUsuariosInput = {
    where: Tb_avaliacoesScalarWhereInput
    data: XOR<Tb_avaliacoesUpdateManyMutationInput, Tb_avaliacoesUncheckedUpdateManyWithoutUsuariosInput>
  }

  export type Tb_avaliacoesScalarWhereInput = {
    AND?: Tb_avaliacoesScalarWhereInput | Tb_avaliacoesScalarWhereInput[]
    OR?: Tb_avaliacoesScalarWhereInput[]
    NOT?: Tb_avaliacoesScalarWhereInput | Tb_avaliacoesScalarWhereInput[]
    idAva?: IntFilter<"Tb_avaliacoes"> | number
    idUsuAva?: IntFilter<"Tb_avaliacoes"> | number
    tipoAva?: StringFilter<"Tb_avaliacoes"> | string
    idPost?: IntFilter<"Tb_avaliacoes"> | number
    tipoPost?: StringFilter<"Tb_avaliacoes"> | string
  }

  export type Tb_perguntasCreateWithoutCategoriasInput = {
    tituloPer: string
    conteudoPer: string
    usuarios: Tb_usuariosCreateNestedOneWithoutPerguntasInput
    respostas?: Tb_respostasCreateNestedManyWithoutPerguntasInput
  }

  export type Tb_perguntasUncheckedCreateWithoutCategoriasInput = {
    idPer?: number
    idUsu: number
    tituloPer: string
    conteudoPer: string
    respostas?: Tb_respostasUncheckedCreateNestedManyWithoutPerguntasInput
  }

  export type Tb_perguntasCreateOrConnectWithoutCategoriasInput = {
    where: Tb_perguntasWhereUniqueInput
    create: XOR<Tb_perguntasCreateWithoutCategoriasInput, Tb_perguntasUncheckedCreateWithoutCategoriasInput>
  }

  export type Tb_perguntasCreateManyCategoriasInputEnvelope = {
    data: Tb_perguntasCreateManyCategoriasInput | Tb_perguntasCreateManyCategoriasInput[]
    skipDuplicates?: boolean
  }

  export type Tb_perguntasUpsertWithWhereUniqueWithoutCategoriasInput = {
    where: Tb_perguntasWhereUniqueInput
    update: XOR<Tb_perguntasUpdateWithoutCategoriasInput, Tb_perguntasUncheckedUpdateWithoutCategoriasInput>
    create: XOR<Tb_perguntasCreateWithoutCategoriasInput, Tb_perguntasUncheckedCreateWithoutCategoriasInput>
  }

  export type Tb_perguntasUpdateWithWhereUniqueWithoutCategoriasInput = {
    where: Tb_perguntasWhereUniqueInput
    data: XOR<Tb_perguntasUpdateWithoutCategoriasInput, Tb_perguntasUncheckedUpdateWithoutCategoriasInput>
  }

  export type Tb_perguntasUpdateManyWithWhereWithoutCategoriasInput = {
    where: Tb_perguntasScalarWhereInput
    data: XOR<Tb_perguntasUpdateManyMutationInput, Tb_perguntasUncheckedUpdateManyWithoutCategoriasInput>
  }

  export type Tb_categoriaCreateWithoutPerguntaInput = {
    nomeCat: string
  }

  export type Tb_categoriaUncheckedCreateWithoutPerguntaInput = {
    idCat?: number
    nomeCat: string
  }

  export type Tb_categoriaCreateOrConnectWithoutPerguntaInput = {
    where: Tb_categoriaWhereUniqueInput
    create: XOR<Tb_categoriaCreateWithoutPerguntaInput, Tb_categoriaUncheckedCreateWithoutPerguntaInput>
  }

  export type Tb_usuariosCreateWithoutPerguntasInput = {
    email: string
    nome: string
    senha: string
    arquivo: string
    respostas?: Tb_respostasCreateNestedManyWithoutUsuariosInput
    avaliacoes?: Tb_avaliacoesCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosUncheckedCreateWithoutPerguntasInput = {
    id?: number
    email: string
    nome: string
    senha: string
    arquivo: string
    respostas?: Tb_respostasUncheckedCreateNestedManyWithoutUsuariosInput
    avaliacoes?: Tb_avaliacoesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosCreateOrConnectWithoutPerguntasInput = {
    where: Tb_usuariosWhereUniqueInput
    create: XOR<Tb_usuariosCreateWithoutPerguntasInput, Tb_usuariosUncheckedCreateWithoutPerguntasInput>
  }

  export type Tb_respostasCreateWithoutPerguntasInput = {
    conteudoRes: string
    usuarios: Tb_usuariosCreateNestedOneWithoutRespostasInput
  }

  export type Tb_respostasUncheckedCreateWithoutPerguntasInput = {
    idRes?: number
    idUsu: number
    conteudoRes: string
  }

  export type Tb_respostasCreateOrConnectWithoutPerguntasInput = {
    where: Tb_respostasWhereUniqueInput
    create: XOR<Tb_respostasCreateWithoutPerguntasInput, Tb_respostasUncheckedCreateWithoutPerguntasInput>
  }

  export type Tb_respostasCreateManyPerguntasInputEnvelope = {
    data: Tb_respostasCreateManyPerguntasInput | Tb_respostasCreateManyPerguntasInput[]
    skipDuplicates?: boolean
  }

  export type Tb_categoriaUpsertWithoutPerguntaInput = {
    update: XOR<Tb_categoriaUpdateWithoutPerguntaInput, Tb_categoriaUncheckedUpdateWithoutPerguntaInput>
    create: XOR<Tb_categoriaCreateWithoutPerguntaInput, Tb_categoriaUncheckedCreateWithoutPerguntaInput>
    where?: Tb_categoriaWhereInput
  }

  export type Tb_categoriaUpdateToOneWithWhereWithoutPerguntaInput = {
    where?: Tb_categoriaWhereInput
    data: XOR<Tb_categoriaUpdateWithoutPerguntaInput, Tb_categoriaUncheckedUpdateWithoutPerguntaInput>
  }

  export type Tb_categoriaUpdateWithoutPerguntaInput = {
    nomeCat?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_categoriaUncheckedUpdateWithoutPerguntaInput = {
    idCat?: IntFieldUpdateOperationsInput | number
    nomeCat?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_usuariosUpsertWithoutPerguntasInput = {
    update: XOR<Tb_usuariosUpdateWithoutPerguntasInput, Tb_usuariosUncheckedUpdateWithoutPerguntasInput>
    create: XOR<Tb_usuariosCreateWithoutPerguntasInput, Tb_usuariosUncheckedCreateWithoutPerguntasInput>
    where?: Tb_usuariosWhereInput
  }

  export type Tb_usuariosUpdateToOneWithWhereWithoutPerguntasInput = {
    where?: Tb_usuariosWhereInput
    data: XOR<Tb_usuariosUpdateWithoutPerguntasInput, Tb_usuariosUncheckedUpdateWithoutPerguntasInput>
  }

  export type Tb_usuariosUpdateWithoutPerguntasInput = {
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    respostas?: Tb_respostasUpdateManyWithoutUsuariosNestedInput
    avaliacoes?: Tb_avaliacoesUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_usuariosUncheckedUpdateWithoutPerguntasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    respostas?: Tb_respostasUncheckedUpdateManyWithoutUsuariosNestedInput
    avaliacoes?: Tb_avaliacoesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_respostasUpsertWithWhereUniqueWithoutPerguntasInput = {
    where: Tb_respostasWhereUniqueInput
    update: XOR<Tb_respostasUpdateWithoutPerguntasInput, Tb_respostasUncheckedUpdateWithoutPerguntasInput>
    create: XOR<Tb_respostasCreateWithoutPerguntasInput, Tb_respostasUncheckedCreateWithoutPerguntasInput>
  }

  export type Tb_respostasUpdateWithWhereUniqueWithoutPerguntasInput = {
    where: Tb_respostasWhereUniqueInput
    data: XOR<Tb_respostasUpdateWithoutPerguntasInput, Tb_respostasUncheckedUpdateWithoutPerguntasInput>
  }

  export type Tb_respostasUpdateManyWithWhereWithoutPerguntasInput = {
    where: Tb_respostasScalarWhereInput
    data: XOR<Tb_respostasUpdateManyMutationInput, Tb_respostasUncheckedUpdateManyWithoutPerguntasInput>
  }

  export type Tb_perguntasCreateWithoutRespostasInput = {
    tituloPer: string
    conteudoPer: string
    categorias: Tb_categoriaCreateNestedOneWithoutPerguntaInput
    usuarios: Tb_usuariosCreateNestedOneWithoutPerguntasInput
  }

  export type Tb_perguntasUncheckedCreateWithoutRespostasInput = {
    idPer?: number
    idCat: number
    idUsu: number
    tituloPer: string
    conteudoPer: string
  }

  export type Tb_perguntasCreateOrConnectWithoutRespostasInput = {
    where: Tb_perguntasWhereUniqueInput
    create: XOR<Tb_perguntasCreateWithoutRespostasInput, Tb_perguntasUncheckedCreateWithoutRespostasInput>
  }

  export type Tb_usuariosCreateWithoutRespostasInput = {
    email: string
    nome: string
    senha: string
    arquivo: string
    perguntas?: Tb_perguntasCreateNestedManyWithoutUsuariosInput
    avaliacoes?: Tb_avaliacoesCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosUncheckedCreateWithoutRespostasInput = {
    id?: number
    email: string
    nome: string
    senha: string
    arquivo: string
    perguntas?: Tb_perguntasUncheckedCreateNestedManyWithoutUsuariosInput
    avaliacoes?: Tb_avaliacoesUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosCreateOrConnectWithoutRespostasInput = {
    where: Tb_usuariosWhereUniqueInput
    create: XOR<Tb_usuariosCreateWithoutRespostasInput, Tb_usuariosUncheckedCreateWithoutRespostasInput>
  }

  export type Tb_perguntasUpsertWithoutRespostasInput = {
    update: XOR<Tb_perguntasUpdateWithoutRespostasInput, Tb_perguntasUncheckedUpdateWithoutRespostasInput>
    create: XOR<Tb_perguntasCreateWithoutRespostasInput, Tb_perguntasUncheckedCreateWithoutRespostasInput>
    where?: Tb_perguntasWhereInput
  }

  export type Tb_perguntasUpdateToOneWithWhereWithoutRespostasInput = {
    where?: Tb_perguntasWhereInput
    data: XOR<Tb_perguntasUpdateWithoutRespostasInput, Tb_perguntasUncheckedUpdateWithoutRespostasInput>
  }

  export type Tb_perguntasUpdateWithoutRespostasInput = {
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    categorias?: Tb_categoriaUpdateOneRequiredWithoutPerguntaNestedInput
    usuarios?: Tb_usuariosUpdateOneRequiredWithoutPerguntasNestedInput
  }

  export type Tb_perguntasUncheckedUpdateWithoutRespostasInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idCat?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_usuariosUpsertWithoutRespostasInput = {
    update: XOR<Tb_usuariosUpdateWithoutRespostasInput, Tb_usuariosUncheckedUpdateWithoutRespostasInput>
    create: XOR<Tb_usuariosCreateWithoutRespostasInput, Tb_usuariosUncheckedCreateWithoutRespostasInput>
    where?: Tb_usuariosWhereInput
  }

  export type Tb_usuariosUpdateToOneWithWhereWithoutRespostasInput = {
    where?: Tb_usuariosWhereInput
    data: XOR<Tb_usuariosUpdateWithoutRespostasInput, Tb_usuariosUncheckedUpdateWithoutRespostasInput>
  }

  export type Tb_usuariosUpdateWithoutRespostasInput = {
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUpdateManyWithoutUsuariosNestedInput
    avaliacoes?: Tb_avaliacoesUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_usuariosUncheckedUpdateWithoutRespostasInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUncheckedUpdateManyWithoutUsuariosNestedInput
    avaliacoes?: Tb_avaliacoesUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_usuariosCreateWithoutAvaliacoesInput = {
    email: string
    nome: string
    senha: string
    arquivo: string
    perguntas?: Tb_perguntasCreateNestedManyWithoutUsuariosInput
    respostas?: Tb_respostasCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosUncheckedCreateWithoutAvaliacoesInput = {
    id?: number
    email: string
    nome: string
    senha: string
    arquivo: string
    perguntas?: Tb_perguntasUncheckedCreateNestedManyWithoutUsuariosInput
    respostas?: Tb_respostasUncheckedCreateNestedManyWithoutUsuariosInput
  }

  export type Tb_usuariosCreateOrConnectWithoutAvaliacoesInput = {
    where: Tb_usuariosWhereUniqueInput
    create: XOR<Tb_usuariosCreateWithoutAvaliacoesInput, Tb_usuariosUncheckedCreateWithoutAvaliacoesInput>
  }

  export type Tb_usuariosUpsertWithoutAvaliacoesInput = {
    update: XOR<Tb_usuariosUpdateWithoutAvaliacoesInput, Tb_usuariosUncheckedUpdateWithoutAvaliacoesInput>
    create: XOR<Tb_usuariosCreateWithoutAvaliacoesInput, Tb_usuariosUncheckedCreateWithoutAvaliacoesInput>
    where?: Tb_usuariosWhereInput
  }

  export type Tb_usuariosUpdateToOneWithWhereWithoutAvaliacoesInput = {
    where?: Tb_usuariosWhereInput
    data: XOR<Tb_usuariosUpdateWithoutAvaliacoesInput, Tb_usuariosUncheckedUpdateWithoutAvaliacoesInput>
  }

  export type Tb_usuariosUpdateWithoutAvaliacoesInput = {
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUpdateManyWithoutUsuariosNestedInput
    respostas?: Tb_respostasUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_usuariosUncheckedUpdateWithoutAvaliacoesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    senha?: StringFieldUpdateOperationsInput | string
    arquivo?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUncheckedUpdateManyWithoutUsuariosNestedInput
    respostas?: Tb_respostasUncheckedUpdateManyWithoutUsuariosNestedInput
  }

  export type Tb_perguntasCreateManyUsuariosInput = {
    idPer?: number
    idCat: number
    tituloPer: string
    conteudoPer: string
  }

  export type Tb_respostasCreateManyUsuariosInput = {
    idRes?: number
    idPer: number
    conteudoRes: string
  }

  export type Tb_avaliacoesCreateManyUsuariosInput = {
    idAva?: number
    tipoAva: string
    idPost: number
    tipoPost: string
  }

  export type Tb_perguntasUpdateWithoutUsuariosInput = {
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    categorias?: Tb_categoriaUpdateOneRequiredWithoutPerguntaNestedInput
    respostas?: Tb_respostasUpdateManyWithoutPerguntasNestedInput
  }

  export type Tb_perguntasUncheckedUpdateWithoutUsuariosInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idCat?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    respostas?: Tb_respostasUncheckedUpdateManyWithoutPerguntasNestedInput
  }

  export type Tb_perguntasUncheckedUpdateManyWithoutUsuariosInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idCat?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasUpdateWithoutUsuariosInput = {
    conteudoRes?: StringFieldUpdateOperationsInput | string
    perguntas?: Tb_perguntasUpdateOneRequiredWithoutRespostasNestedInput
  }

  export type Tb_respostasUncheckedUpdateWithoutUsuariosInput = {
    idRes?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasUncheckedUpdateManyWithoutUsuariosInput = {
    idRes?: IntFieldUpdateOperationsInput | number
    idPer?: IntFieldUpdateOperationsInput | number
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_avaliacoesUpdateWithoutUsuariosInput = {
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_avaliacoesUncheckedUpdateWithoutUsuariosInput = {
    idAva?: IntFieldUpdateOperationsInput | number
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_avaliacoesUncheckedUpdateManyWithoutUsuariosInput = {
    idAva?: IntFieldUpdateOperationsInput | number
    tipoAva?: StringFieldUpdateOperationsInput | string
    idPost?: IntFieldUpdateOperationsInput | number
    tipoPost?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_perguntasCreateManyCategoriasInput = {
    idPer?: number
    idUsu: number
    tituloPer: string
    conteudoPer: string
  }

  export type Tb_perguntasUpdateWithoutCategoriasInput = {
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    usuarios?: Tb_usuariosUpdateOneRequiredWithoutPerguntasNestedInput
    respostas?: Tb_respostasUpdateManyWithoutPerguntasNestedInput
  }

  export type Tb_perguntasUncheckedUpdateWithoutCategoriasInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
    respostas?: Tb_respostasUncheckedUpdateManyWithoutPerguntasNestedInput
  }

  export type Tb_perguntasUncheckedUpdateManyWithoutCategoriasInput = {
    idPer?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    tituloPer?: StringFieldUpdateOperationsInput | string
    conteudoPer?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasCreateManyPerguntasInput = {
    idRes?: number
    idUsu: number
    conteudoRes: string
  }

  export type Tb_respostasUpdateWithoutPerguntasInput = {
    conteudoRes?: StringFieldUpdateOperationsInput | string
    usuarios?: Tb_usuariosUpdateOneRequiredWithoutRespostasNestedInput
  }

  export type Tb_respostasUncheckedUpdateWithoutPerguntasInput = {
    idRes?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }

  export type Tb_respostasUncheckedUpdateManyWithoutPerguntasInput = {
    idRes?: IntFieldUpdateOperationsInput | number
    idUsu?: IntFieldUpdateOperationsInput | number
    conteudoRes?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use Tb_usuariosCountOutputTypeDefaultArgs instead
     */
    export type Tb_usuariosCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_usuariosCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_categoriaCountOutputTypeDefaultArgs instead
     */
    export type Tb_categoriaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_categoriaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_perguntasCountOutputTypeDefaultArgs instead
     */
    export type Tb_perguntasCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_perguntasCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_usuariosDefaultArgs instead
     */
    export type Tb_usuariosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_usuariosDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_categoriaDefaultArgs instead
     */
    export type Tb_categoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_categoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_perguntasDefaultArgs instead
     */
    export type Tb_perguntasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_perguntasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_respostasDefaultArgs instead
     */
    export type Tb_respostasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_respostasDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Tb_avaliacoesDefaultArgs instead
     */
    export type Tb_avaliacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Tb_avaliacoesDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}